#!/usr/bin/env python3
"""
Accumulator Scalping Bot - Modo Standalone
Refatorado para seguir fielmente a estrat√©gia do Scalping Bot.xml
Com l√≥gica de entrada corrigida e resili√™ncia a falhas
"""

import os
import sys
import asyncio
import time
import logging
import json
import threading
import websockets
import uuid
from datetime import datetime
from typing import Optional, Dict, Any, List
from dotenv import load_dotenv
from supabase import create_client, Client
from robust_order_system import RobustOrderSystem, OperationType
from enhanced_sync_system import EnhancedSyncSystem
from aiohttp import web
from error_handler import RobustErrorHandler, with_error_handling, ErrorType, ErrorSeverity
from enhanced_tick_buffer import EnhancedTickBuffer
from websocket_recovery import WebSocketRecoveryManager
from signal_queue_system import ThreadSafeSignalQueue
from system_health_monitor import SystemHealthMonitor

# Carregar vari√°veis de ambiente
load_dotenv()

# Adicionar o diret√≥rio atual ao path
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

# Configura√ß√£o de logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('accumulator_standalone.log', encoding='utf-8'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# ============================================================================
# PAR√ÇMETROS DE GEST√ÉO (CONFORME XML ORIGINAL)
# ============================================================================
NOME_BOT = "Accumulator_Scalping_Bot"
STAKE_INICIAL = 5.0  # initial stake - alterado para 5
STAKE_MAXIMO_DERIV = 1000.0  # Limite m√°ximo de stake permitido pela Deriv API
TAKE_PROFIT_PERCENTUAL = 0.45  # 45% (Return%) - Conforme solicita√ß√£o
ATIVO = 'R_10'
GROWTH_RATE = 0.02  # 2% - Valor corrigido conforme solicita√ß√£o
WIN_STOP = 1000.0  # Meta de ganho di√°rio
LOSS_LIMIT = 1000.0  # Limite de perda di√°ria
KHIZZBOT = 50  # Valor khizzbot conforme XML original

# ============================================================================
# CONFIGURA√á√ÉO DE CONTAS - THUNDERBOT EXCLUSIVO
# ============================================================================
# ‚ö†Ô∏è ESTAS CREDENCIAIS S√ÉO EXCLUSIVAS DO TUNDERBOTALAVANCA.PY
# ‚ö†Ô∏è OUTROS BOTS N√ÉO S√ÉO AFETADOS

THUNDERBOT_ACCOUNTS = [
    {
        "name": "ThunderBot_Principal",
        "token": "5iD3wgrYUz39kzS",  # Token exclusivo ThunderBot
        "app_id": "105327",            # App ID exclusivo ThunderBot
        "enabled": True,
        "max_concurrent_contracts": 1
    },
    # Contas futuras (desabilitadas por padr√£o):
    {
        "name": "ThunderBot_Secundario",
        "token": "",  # Adicionar token quando necess√°rio
        "app_id": "105327",
        "enabled": False,  # ‚ö†Ô∏è DESABILITADO - n√£o ser√° usado
        "max_concurrent_contracts": 1
    },
    {
        "name": "ThunderBot_Terciario",
        "token": "",  # Adicionar token quando necess√°rio
        "app_id": "105327",
        "enabled": False,  # ‚ö†Ô∏è DESABILITADO - n√£o ser√° usado
        "max_concurrent_contracts": 1
    }
]

# Filtrar apenas contas habilitadas E com token v√°lido
ACTIVE_THUNDERBOT_ACCOUNTS = [
    acc for acc in THUNDERBOT_ACCOUNTS
    if acc["enabled"] and acc["token"] and len(acc["token"]) > 10
]

# Valida√ß√£o: garantir que pelo menos a conta principal est√° ativa
if len(ACTIVE_THUNDERBOT_ACCOUNTS) == 0:
    raise Exception("ERRO: Nenhuma conta ThunderBot v√°lida configurada!")

print(f"[ThunderBot] Contas ativas: {len(ACTIVE_THUNDERBOT_ACCOUNTS)}")
for acc in ACTIVE_THUNDERBOT_ACCOUNTS:
    print(f"  - {acc['name']}: Token ...{acc['token'][-4:]}")

# Manter compatibilidade com c√≥digo existente
ACCOUNTS = THUNDERBOT_ACCOUNTS
ACTIVE_ACCOUNTS = ACTIVE_THUNDERBOT_ACCOUNTS

# ============================================================================
# CLASSES AUXILIARES AUTO-CONTIDAS - THUNDERBOT EXCLUSIVO
# ============================================================================

class CircuitBreaker:
    """Circuit Breaker para prote√ß√£o contra falhas em cascata - ThunderBot"""
    
    CLOSED = "CLOSED"
    OPEN = "OPEN"
    HALF_OPEN = "HALF_OPEN"
    
    def __init__(self, failure_threshold=3, recovery_timeout=60, name="CircuitBreaker"):
        self.failure_threshold = failure_threshold
        self.recovery_timeout = recovery_timeout
        self.failure_count = 0
        self.last_failure_time = None
        self.state = self.CLOSED
        self.name = name
        
        logger.info(f"üîß {self.name} inicializado: threshold={failure_threshold}, timeout={recovery_timeout}s")
    
    def _can_execute(self):
        """Verifica se pode executar opera√ß√£o baseado no estado atual"""
        if self.state == self.CLOSED:
            return True
        elif self.state == self.OPEN:
            if time.time() - self.last_failure_time > self.recovery_timeout:
                self.state = self.HALF_OPEN
                logger.info("üîÑ CircuitBreaker: OPEN -> HALF_OPEN (tentando recupera√ß√£o)")
                return True
            return False
        elif self.state == self.HALF_OPEN:
            return True
        return False
    
    async def call(self, func, *args, **kwargs):
        """Executa fun√ß√£o com prote√ß√£o do circuit breaker"""
        if not self._can_execute():
            raise Exception(f"CircuitBreaker OPEN - aguarde {self.recovery_timeout}s para recupera√ß√£o")
        
        try:
            if asyncio.iscoroutinefunction(func):
                result = await func(*args, **kwargs)
            else:
                result = func(*args, **kwargs)
            
            # Sucesso - resetar contador se estava em HALF_OPEN
            if self.state == self.HALF_OPEN:
                self.state = self.CLOSED
                self.failure_count = 0
                logger.info("‚úÖ CircuitBreaker: HALF_OPEN -> CLOSED (recupera√ß√£o bem-sucedida)")
            
            return result
            
        except Exception as e:
            self.failure_count += 1
            self.last_failure_time = time.time()
            
            logger.warning(f"‚ö†Ô∏è CircuitBreaker: Falha {self.failure_count}/{self.failure_threshold}")
            
            if self.failure_count >= self.failure_threshold:
                self.state = self.OPEN
                logger.error(f"üö® CircuitBreaker: {self.CLOSED} -> OPEN (limite de falhas atingido)")
            
            raise e
    
    def get_status(self):
        """Retorna status atual do circuit breaker"""
        return {
            "state": self.state,
            "failure_count": self.failure_count,
            "failure_threshold": self.failure_threshold,
            "last_failure_time": self.last_failure_time,
            "recovery_timeout": self.recovery_timeout
        }

class ThunderBotConnectionManager:
    """Gerenciador de WebSocket espec√≠fico do ThunderBot"""
    
    def __init__(self, account_config):
        self.account_config = account_config
        self.account_name = account_config['name']
        self.token = account_config['token']
        self.app_id = account_config['app_id']
        
        # Estado da conex√£o
        self.connection = None
        self.is_connected = False
        self.last_heartbeat = None
        self.heartbeat_interval = 30  # 30s conforme solicitado
        
        # Reconex√£o com backoff exponencial
        self.reconnect_attempts = 0
        self.max_reconnect_attempts = 5
        self.base_reconnect_delay = 2
        self.max_reconnect_delay = 60
        
        # Circuit breaker integrado
        self.circuit_breaker = CircuitBreaker(failure_threshold=3, recovery_timeout=60)
        
        logger.info(f"üîß ThunderBotConnectionManager criado para: {self.account_name}")
    
    async def connect(self):
        """Estabelece conex√£o WebSocket com as credenciais ThunderBot"""
        try:
            return await self.circuit_breaker.call(self._do_connect)
        except Exception as e:
            logger.error(f"‚ùå Falha na conex√£o ThunderBot {self.account_name}: {e}")
            return False
    
    async def _do_connect(self):
        """Implementa√ß√£o real da conex√£o"""
        try:
            # Usar as credenciais espec√≠ficas do ThunderBot
            logger.info(f"üîå Conectando ThunderBot {self.account_name} (Token: ...{self.token[-4:]})")
            
            # Aqui seria a implementa√ß√£o real da conex√£o WebSocket
            # Por enquanto, simular sucesso para teste
            self.is_connected = True
            self.reconnect_attempts = 0
            self.last_heartbeat = time.time()
            
            logger.info(f"‚úÖ ThunderBot {self.account_name} conectado com sucesso")
            
            # Iniciar heartbeat autom√°tico
            asyncio.create_task(self._heartbeat_loop())
            
            return True
            
        except Exception as e:
            self.is_connected = False
            raise e
    
    async def _heartbeat_loop(self):
        """Loop de heartbeat autom√°tico a cada 30s"""
        while self.is_connected:
            try:
                await asyncio.sleep(self.heartbeat_interval)
                
                if self.is_connected:
                    await self._send_heartbeat()
                    
            except Exception as e:
                logger.error(f"‚ùå Erro no heartbeat {self.account_name}: {e}")
                await self._handle_connection_error()
    
    async def _send_heartbeat(self):
        """Envia heartbeat para manter conex√£o ativa"""
        try:
            self.last_heartbeat = time.time()
            logger.debug(f"üíì Heartbeat enviado para {self.account_name}")
            
        except Exception as e:
            logger.error(f"‚ùå Falha no heartbeat {self.account_name}: {e}")
            raise e
    
    async def _handle_connection_error(self):
        """Trata erros de conex√£o com reconex√£o autom√°tica"""
        self.is_connected = False
        
        # Calcular delay com backoff exponencial
        delay = min(
            self.base_reconnect_delay * (2 ** self.reconnect_attempts),
            self.max_reconnect_delay
        )
        
        self.reconnect_attempts += 1
        
        if self.reconnect_attempts <= self.max_reconnect_attempts:
            logger.info(f"üîÑ Reconectando {self.account_name} em {delay}s (tentativa {self.reconnect_attempts})")
            await asyncio.sleep(delay)
            await self.connect()
        else:
            logger.error(f"üíÄ ThunderBot {self.account_name}: m√°ximo de tentativas de reconex√£o atingido")
    
    async def disconnect(self):
        """Desconecta WebSocket de forma segura"""
        try:
            self.is_connected = False
            if self.connection:
                await self.connection.close()
            logger.info(f"‚úÖ ThunderBot {self.account_name} desconectado")
        except Exception as e:
            logger.error(f"‚ùå Erro ao desconectar {self.account_name}: {e}")
    
    def get_status(self):
        """Retorna status da conex√£o"""
        return {
            "account_name": self.account_name,
            "is_connected": self.is_connected,
            "last_heartbeat": self.last_heartbeat,
            "reconnect_attempts": self.reconnect_attempts,
            "circuit_breaker": self.circuit_breaker.get_status()
        }

class ThunderBotOperationQueue:
    """Fila de opera√ß√µes espec√≠fica por conta ThunderBot"""
    
    def __init__(self, account_name):
        self.account_name = account_name
        self.queue = asyncio.Queue()
        self.processing = False
        self.current_operation = None
        self.operation_lock = asyncio.Lock()  # Lock ass√≠ncrono por conta
        
        # Sistema de prioridades
        self.priority_queue = {
            "HIGH": asyncio.Queue(),
            "MEDIUM": asyncio.Queue(), 
            "LOW": asyncio.Queue()
        }
        
        # Garantir 1 opera√ß√£o ACCU por vez
        self.accu_operation_active = False
        self.accu_lock = asyncio.Lock()
        
        logger.info(f"üîß ThunderBotOperationQueue criada para: {account_name}")
    
    async def add_operation(self, operation_data, priority="MEDIUM"):
        """Adiciona opera√ß√£o √† fila com prioridade"""
        async with self.operation_lock:
            operation = {
                "id": f"{self.account_name}_{int(time.time() * 1000)}",
                "account_name": self.account_name,
                "data": operation_data,
                "priority": priority,
                "timestamp": time.time(),
                "type": operation_data.get("type", "UNKNOWN")
            }
            
            # Verificar se √© opera√ß√£o ACCU
            if operation["type"] == "ACCU":
                if self.accu_operation_active:
                    logger.warning(f"‚ö†Ô∏è Opera√ß√£o ACCU rejeitada - j√° existe uma ativa em {self.account_name}")
                    return False
            
            await self.priority_queue[priority].put(operation)
            logger.info(f"üì• Opera√ß√£o adicionada √† fila {self.account_name}: {operation['id']} (prioridade: {priority})")
            
            return True
    
    async def get_next_operation(self):
        """Obt√©m pr√≥xima opera√ß√£o respeitando prioridades"""
        # Verificar filas por prioridade
        for priority in ["HIGH", "MEDIUM", "LOW"]:
            if not self.priority_queue[priority].empty():
                operation = await self.priority_queue[priority].get()
                
                # Marcar opera√ß√£o ACCU como ativa
                if operation["type"] == "ACCU":
                    async with self.accu_lock:
                        self.accu_operation_active = True
                
                self.current_operation = operation
                return operation
        
        return None
    
    async def complete_operation(self, operation_id, success=True):
        """Marca opera√ß√£o como conclu√≠da"""
        if self.current_operation and self.current_operation["id"] == operation_id:
            # Liberar lock ACCU se necess√°rio
            if self.current_operation["type"] == "ACCU":
                async with self.accu_lock:
                    self.accu_operation_active = False
            
            status = "‚úÖ SUCESSO" if success else "‚ùå FALHA"
            logger.info(f"üì§ Opera√ß√£o conclu√≠da {self.account_name}: {operation_id} - {status}")
            
            self.current_operation = None
            self.processing = False
    
    def is_empty(self):
        """Verifica se todas as filas est√£o vazias"""
        return all(queue.empty() for queue in self.priority_queue.values())
    
    def get_queue_status(self):
        """Retorna status das filas"""
        return {
            "account_name": self.account_name,
            "processing": self.processing,
            "current_operation": self.current_operation,
            "accu_operation_active": self.accu_operation_active,
            "queue_sizes": {
                priority: queue.qsize() 
                for priority, queue in self.priority_queue.items()
            },
            "total_queued": sum(queue.qsize() for queue in self.priority_queue.values())
        }
    
    async def disconnect(self):
        """Desconecta de forma segura"""
        self.is_connected = False
        if self.connection:
            await self.connection.close()


# ============================================================================
# CLASSE DE GERENCIAMENTO DE CONTA THUNDERBOT
# ============================================================================
class ThunderBotAccountManager:
    """Gerencia ciclo de vida de UMA conta ThunderBot"""
    
    def __init__(self, account_name, account_config):
        self.account_name = account_name
        self.account_config = account_config
        self.logger = logging.getLogger(f"ThunderBotAccountManager_{account_name}")
        
        # Componentes da conta
        self.circuit_breaker = CircuitBreaker(
            failure_threshold=3,
            recovery_timeout=60,
            name=f"CB_{account_name}"
        )
        self.connection_manager = ThunderBotConnectionManager(account_config)
        self.operation_queue = ThunderBotOperationQueue(account_name)
        
        # Estado da conta
        self.is_available = True
        self.active_contracts = {}  # Contratos ACCU ativos
        self.last_operation_time = None
        self.operation_lock = asyncio.Lock()
        
        self.logger.info(f"ThunderBotAccountManager inicializado para conta: {account_name}")
    
    async def initialize(self):
        """Inicializa a conta e seus componentes"""
        try:
            self.logger.info(f"Inicializando conta {self.account_name}...")
            
            # Conecta o WebSocket
            await self.connection_manager.connect()
            
            # Verifica disponibilidade inicial
            await self.validate_availability()
            
            self.logger.info(f"Conta {self.account_name} inicializada com sucesso")
            return True
            
        except Exception as e:
            self.logger.error(f"Erro ao inicializar conta {self.account_name}: {e}")
            return False
    
    async def validate_availability(self):
        """Valida se a conta est√° dispon√≠vel para operar"""
        try:
            # Verifica se o circuit breaker est√° fechado
            if not self.circuit_breaker.is_closed():
                self.is_available = False
                self.logger.warning(f"Conta {self.account_name} indispon√≠vel - Circuit Breaker aberto")
                return False
            
            # Verifica conex√£o WebSocket
            if not self.connection_manager.is_connected():
                self.is_available = False
                self.logger.warning(f"Conta {self.account_name} indispon√≠vel - WebSocket desconectado")
                return False
            
            # Verifica se h√° opera√ß√£o ACCU ativa
            if self.operation_queue.accu_operation_active:
                self.is_available = False
                self.logger.info(f"Conta {self.account_name} indispon√≠vel - Opera√ß√£o ACCU ativa")
                return False
            
            self.is_available = True
            return True
            
        except Exception as e:
            self.logger.error(f"Erro ao validar disponibilidade da conta {self.account_name}: {e}")
            self.is_available = False
            return False
    
    async def execute_operation(self, operation_data):
        """Executa uma opera√ß√£o na conta"""
        async with self.operation_lock:
            try:
                # Valida disponibilidade antes de operar
                if not await self.validate_availability():
                    raise Exception(f"Conta {self.account_name} n√£o est√° dispon√≠vel para opera√ß√£o")
                
                # Adiciona opera√ß√£o √† fila
                await self.operation_queue.add_operation(operation_data)
                
                # Atualiza tempo da √∫ltima opera√ß√£o
                self.last_operation_time = datetime.now()
                
                self.logger.info(f"Opera√ß√£o executada na conta {self.account_name}")
                return True
                
            except Exception as e:
                self.logger.error(f"Erro ao executar opera√ß√£o na conta {self.account_name}: {e}")
                await self.circuit_breaker.record_failure()
                return False
    
    def add_active_contract(self, contract_id, contract_data):
        """Adiciona contrato ACCU ativo ao rastreamento"""
        self.active_contracts[contract_id] = {
            "data": contract_data,
            "start_time": datetime.now(),
            "status": "active"
        }
        self.logger.info(f"Contrato ACCU {contract_id} adicionado ao rastreamento da conta {self.account_name}")
    
    def remove_active_contract(self, contract_id):
        """Remove contrato ACCU do rastreamento"""
        if contract_id in self.active_contracts:
            del self.active_contracts[contract_id]
            self.logger.info(f"Contrato ACCU {contract_id} removido do rastreamento da conta {self.account_name}")
    
    def get_account_status(self):
        """Retorna status completo da conta"""
        return {
            "account_name": self.account_name,
            "is_available": self.is_available,
            "circuit_breaker_status": self.circuit_breaker.get_status(),
            "connection_status": self.connection_manager.get_status(),
            "queue_status": self.operation_queue.get_queue_status(),
            "active_contracts": len(self.active_contracts),
            "last_operation_time": self.last_operation_time.isoformat() if self.last_operation_time else None
        }
    
    async def buy_accu(self, params):
        """Executa compra de contrato ACCU atrav√©s do connection manager"""
        async with self.operation_lock:
            try:
                # Valida disponibilidade antes de operar
                if not await self.validate_availability():
                    raise Exception(f"Conta {self.account_name} n√£o est√° dispon√≠vel para opera√ß√£o ACCU")
                
                # Marca opera√ß√£o ACCU como ativa
                self.operation_queue.accu_operation_active = True
                
                # Executa proposta atrav√©s do connection manager
                proposal_result = await self.connection_manager.send_message(params)
                
                if not proposal_result or 'proposal' not in proposal_result:
                    raise Exception(f"Falha na proposta ACCU: {proposal_result}")
                
                proposal = proposal_result['proposal']
                proposal_id = proposal.get('id')
                ask_price = proposal.get('ask_price')
                
                if not proposal_id or not ask_price:
                    raise Exception(f"Dados da proposta inv√°lidos: {proposal}")
                
                # Executa compra
                buy_params = {
                    "buy": proposal_id,
                    "price": float(ask_price)
                }
                
                buy_result = await self.connection_manager.send_message(buy_params)
                
                if not buy_result or 'buy' not in buy_result:
                    raise Exception(f"Falha na compra ACCU: {buy_result}")
                
                contract_id = buy_result['buy'].get('contract_id')
                
                if contract_id:
                    # Adiciona contrato ao rastreamento
                    self.add_active_contract(contract_id, {
                        "proposal_id": proposal_id,
                        "ask_price": ask_price,
                        "params": params
                    })
                    
                    # Atualiza tempo da √∫ltima opera√ß√£o
                    self.last_operation_time = datetime.now()
                    
                    self.logger.info(f"Compra ACCU executada com sucesso - Contract ID: {contract_id}")
                    return contract_id
                else:
                    raise Exception(f"Contract ID n√£o encontrado na resposta: {buy_result}")
                
            except Exception as e:
                self.logger.error(f"Erro ao executar compra ACCU na conta {self.account_name}: {e}")
                await self.circuit_breaker.record_failure()
                return None
            finally:
                # Marca opera√ß√£o ACCU como inativa
                self.operation_queue.accu_operation_active = False

    async def shutdown(self):
        """Desliga a conta de forma segura"""
        try:
            self.logger.info(f"Desligando conta {self.account_name}...")
            
            # Para opera√ß√µes pendentes
            await self.operation_queue.disconnect()
            
            # Desconecta WebSocket
            await self.connection_manager.disconnect()
            
            # Limpa contratos ativos
            self.active_contracts.clear()
            
            self.is_available = False
            self.logger.info(f"Conta {self.account_name} desligada com sucesso")
            
        except Exception as e:
            self.logger.error(f"Erro ao desligar conta {self.account_name}: {e}")


# ============================================================================
# CLASSE DE MONITORAMENTO DE SA√öDE THUNDERBOT
# ============================================================================
class ThunderBotHealthMonitor:
    """Monitora sa√∫de APENAS das contas ThunderBot"""
    
    def __init__(self, account_managers):
        self.account_managers = account_managers  # Dict de ThunderBotAccountManager
        self.logger = logging.getLogger("ThunderBotHealthMonitor")
        self.monitoring = False
        self.monitor_task = None
        self.check_interval = 60  # Verifica a cada 60 segundos
        
        self.logger.info(f"ThunderBotHealthMonitor inicializado para {len(account_managers)} contas ThunderBot")
    
    async def start_monitoring(self):
        """Inicia o monitoramento de sa√∫de"""
        if self.monitoring:
            self.logger.warning("Monitoramento j√° est√° ativo")
            return
        
        self.monitoring = True
        self.monitor_task = asyncio.create_task(self._monitor_loop())
        self.logger.info("Monitoramento de sa√∫de ThunderBot iniciado")
    
    async def stop_monitoring(self):
        """Para o monitoramento de sa√∫de"""
        if not self.monitoring:
            return
        
        self.monitoring = False
        if self.monitor_task:
            self.monitor_task.cancel()
            try:
                await self.monitor_task
            except asyncio.CancelledError:
                pass
        
        self.logger.info("Monitoramento de sa√∫de ThunderBot parado")
    
    async def _monitor_loop(self):
        """Loop principal de monitoramento"""
        while self.monitoring:
            try:
                await self._check_all_accounts()
                await asyncio.sleep(self.check_interval)
                
            except asyncio.CancelledError:
                break
            except Exception as e:
                self.logger.error(f"Erro no loop de monitoramento: {e}")
                await asyncio.sleep(5)  # Espera menor em caso de erro
    
    async def _check_all_accounts(self):
        """Verifica sa√∫de de todas as contas ThunderBot"""
        self.logger.debug("Verificando sa√∫de de todas as contas ThunderBot...")
        
        for account_name, account_manager in self.account_managers.items():
            try:
                await self._check_account_health(account_name, account_manager)
            except Exception as e:
                self.logger.error(f"Erro ao verificar sa√∫de da conta {account_name}: {e}")
    
    async def _check_account_health(self, account_name, account_manager):
        """Verifica sa√∫de de uma conta espec√≠fica"""
        try:
            # Valida disponibilidade da conta
            is_healthy = await account_manager.validate_availability()
            
            if not is_healthy:
                self.logger.warning(f"Conta {account_name} n√£o est√° saud√°vel")
                
                # Tenta reconectar se necess√°rio
                if not account_manager.connection_manager.is_connected():
                    self.logger.info(f"Tentando reconectar conta {account_name}...")
                    await self._attempt_reconnection(account_name, account_manager)
            else:
                self.logger.debug(f"Conta {account_name} est√° saud√°vel")
                
        except Exception as e:
            self.logger.error(f"Erro ao verificar sa√∫de da conta {account_name}: {e}")
    
    async def _attempt_reconnection(self, account_name, account_manager):
        """Tenta reconectar uma conta"""
        try:
            # Desconecta primeiro
            await account_manager.connection_manager.disconnect()
            
            # Aguarda um pouco
            await asyncio.sleep(2)
            
            # Tenta reconectar
            success = await account_manager.connection_manager.connect()
            
            if success:
                self.logger.info(f"Conta {account_name} reconectada com sucesso")
                # Revalida disponibilidade
                await account_manager.validate_availability()
            else:
                self.logger.error(f"Falha ao reconectar conta {account_name}")
                
        except Exception as e:
            self.logger.error(f"Erro ao tentar reconectar conta {account_name}: {e}")
    
    def get_health_report(self):
        """Retorna relat√≥rio de sa√∫de de todas as contas"""
        report = {
            "monitoring_active": self.monitoring,
            "check_interval": self.check_interval,
            "total_accounts": len(self.account_managers),
            "accounts": {}
        }
        
        for account_name, account_manager in self.account_managers.items():
            try:
                account_status = account_manager.get_account_status()
                report["accounts"][account_name] = {
                    "is_available": account_status["is_available"],
                    "connection_status": account_status["connection_status"]["is_connected"],
                    "circuit_breaker_state": account_status["circuit_breaker_status"]["state"],
                    "active_contracts": account_status["active_contracts"],
                    "last_operation": account_status["last_operation_time"]
                }
            except Exception as e:
                report["accounts"][account_name] = {
                    "error": str(e),
                    "status": "unknown"
                }
        
        return report
    
    async def force_health_check(self):
        """For√ßa uma verifica√ß√£o imediata de sa√∫de"""
        self.logger.info("Executando verifica√ß√£o for√ßada de sa√∫de...")
        await self._check_all_accounts()
        return self.get_health_report()


# ============================================================================
# CLASSE DE GERENCIAMENTO DA API - WEBSOCKET NATIVO
# ============================================================================
class DerivWebSocketNativo:
    """Gerenciador de API WebSocket nativo com suporte a m√∫ltiplas contas"""
    
    def __init__(self, account_config=None):
        # WebSocket connection
        self.ws = None
        self.connected = False
        
        # Request management
        self.req_id_counter = 0
        self.req_id_lock = threading.Lock()
        self.pending_requests = {}
        self.request_timeout = 15  # Otimizado para menor lat√™ncia
        
        # Rate limiting
        self.last_request_time = 0
        self.min_request_interval = 0.5  # 2 requests per second max
        
        # Credentials - usar configura√ß√£o da conta ou fallback para vari√°veis de ambiente
        if account_config:
            self.account_name = account_config.get('name', 'Unknown')
            self.app_id = account_config.get('app_id', '105327')
            self.api_token = account_config.get('token')
            
            if not self.api_token or self.api_token.startswith('SEU_TOKEN_'):
                raise ValueError(f"‚ùå Token inv√°lido para a conta {self.account_name}")
        else:
            # Fallback para vari√°veis de ambiente (compatibilidade)
            self.account_name = "Default"
            self.app_id = "85515"
            self.api_token = os.getenv('DERIV_API_TOKEN')
            
            if not self.api_token:
                raise ValueError("‚ùå DERIV_API_TOKEN deve estar definido no arquivo .env")
        
        # Connection state
        self.session_id = None
        self.authorized = False
        
        logger.info(f"üîß DerivWebSocketNativo inicializado - Conta: {self.account_name}, App ID: {self.app_id}")
    
    async def connect(self):
        """Conecta ao WebSocket da Deriv com autentica√ß√£o"""
        max_retries = 3
        for attempt in range(max_retries):
            try:
                logger.info(f"üîó Tentativa {attempt + 1}/{max_retries} - Conectando WebSocket...")
                
                # Fechar conex√£o anterior se existir
                if hasattr(self, 'account_manager') and self.account_manager:
                    try:
                        await self.account_manager.connection_manager.close()
                    except:
                        pass
                
                # URL WebSocket conforme especifica√ß√£o
                ws_url = f"wss://ws.binaryws.com/websockets/v3?app_id={self.app_id}"
                
                # Conectar WebSocket
                self.ws = await websockets.connect(ws_url)
                logger.info(f"üîó WebSocket conectado: {ws_url}")
                
                # Iniciar task para processar mensagens
                asyncio.create_task(self._handle_messages())
                
                # Autenticar
                auth_success = await self._authenticate()
                if auth_success:
                    self.connected = True
                    logger.info(f"‚úÖ Conex√£o WebSocket estabelecida - Session: {self.session_id}")
                    
                    # Iniciar keepalive
                    asyncio.create_task(self._keepalive_loop())
                    
                    return True
                else:
                    logger.error("‚ùå Falha na autentica√ß√£o")
                    
            except Exception as e:
                logger.error(f"‚ùå Erro na tentativa {attempt + 1}: {e}")
                if attempt < max_retries - 1:
                    await asyncio.sleep(5)
                    
        logger.error("‚ùå Falha ao estabelecer conex√£o WebSocket")
        return False
    
    def _get_next_req_id(self):
        """Gera pr√≥ximo request ID thread-safe"""
        with self.req_id_lock:
            self.req_id_counter += 1
            return self.req_id_counter
    
    async def _authenticate(self):
        """Autentica com a API da Deriv"""
        try:
            req_id = self._get_next_req_id()
            auth_message = {
                "authorize": self.api_token,
                "req_id": req_id
            }
            
            logger.info(f"üîê Enviando autentica√ß√£o - req_id: {req_id}")
            response = await self._send_request(auth_message)
            
            if 'error' in response:
                logger.error(f"‚ùå Erro de autentica√ß√£o: {response['error']['message']}")
                return False
            
            if 'authorize' in response:
                self.authorized = True
                self.session_id = response['authorize'].get('loginid')
                logger.info(f"‚úÖ Autenticado com sucesso - LoginID: {self.session_id}")
                return True
            
            return False
            
        except Exception as e:
            logger.error(f"‚ùå Erro na autentica√ß√£o: {e}")
            return False
    
    async def _handle_messages(self):
        """Processa mensagens recebidas do WebSocket"""
        try:
            async for message in self.ws:
                try:
                    data = json.loads(message)
                    req_id = data.get('req_id')
                    
                    logger.debug(f"üì• Mensagem recebida - req_id: {req_id}, data: {data}")
                    
                    # NOVO: Processar ticks em tempo real
                    if 'tick' in data:
                        await self._process_tick(data['tick'])
                    
                    if req_id and req_id in self.pending_requests:
                        future = self.pending_requests.pop(req_id)
                        if not future.done():
                            future.set_result(data)
                    
                except json.JSONDecodeError as e:
                    logger.error(f"‚ùå Erro ao decodificar JSON: {e}")
                except Exception as e:
                    logger.error(f"‚ùå Erro ao processar mensagem: {e}")
                    
        except websockets.exceptions.ConnectionClosed:
            logger.warning("‚ö†Ô∏è Conex√£o WebSocket fechada")
            self.connected = False
        except Exception as e:
            logger.error(f"‚ùå Erro no handler de mensagens: {e}")
            self.connected = False
    
    async def _keepalive_loop(self):
        """Loop de ping/pong para manter conex√£o ativa"""
        while self.connected and self.ws:
            try:
                await asyncio.sleep(30)  # Ping a cada 30 segundos
                if self.connected and self.ws:
                    req_id = self._get_next_req_id()
                    ping_message = {"ping": 1, "req_id": req_id}
                    
                    response = await self._send_request(ping_message)
                    if 'ping' in response:
                        logger.debug(f"üíì Ping OK - req_id: {req_id}")
                    else:
                        logger.warning("‚ö†Ô∏è Ping falhou - Reconectando...")
                        await self._reconnect()
                        
            except Exception as e:
                logger.error(f"‚ùå Erro no keepalive: {e} - Reconectando...")
                await self._reconnect()
    
    async def _reconnect(self):
        """Reconecta automaticamente"""
        logger.info("üîÑ Iniciando reconex√£o...")
        self.connected = False
        await self.connect()
    
    async def _send_request(self, message):
        """Envia request e aguarda response"""
        try:
            # Rate limiting
            current_time = time.time()
            time_since_last = current_time - self.last_request_time
            if time_since_last < self.min_request_interval:
                await asyncio.sleep(self.min_request_interval - time_since_last)
            
            req_id = message.get('req_id')
            if not req_id:
                req_id = self._get_next_req_id()
                message['req_id'] = req_id
            
            # Criar Future para aguardar response
            future = asyncio.Future()
            self.pending_requests[req_id] = future
            
            # Enviar mensagem
            message_str = json.dumps(message)
            logger.debug(f"üì§ Enviando: {message_str}")
            
            await self.account_manager.connection_manager.send(message_str)
            self.last_request_time = time.time()
            
            # Aguardar response com timeout
            try:
                response = await asyncio.wait_for(future, timeout=self.request_timeout)
                return response
            except asyncio.TimeoutError:
                # Cleanup em caso de timeout
                self.pending_requests.pop(req_id, None)
                raise Exception(f"Timeout aguardando response para req_id {req_id}")
                
        except Exception as e:
            # Cleanup em caso de erro
            self.pending_requests.pop(req_id, None)
            raise e
    
    async def ensure_connection(self):
        """Garante que a conex√£o WebSocket est√° ativa"""
        if not self.connected or not self.ws or not self.authorized:
            await self.connect()
    
    async def buy(self, params):
        """Executa compra usando WebSocket nativo"""
        await self.ensure_connection()
        
        try:
            # Estrutura de compra conforme documenta√ß√£o Deriv
            buy_message = {
                "buy": str(params["buy"]),
                "price": float(params["price"])
            }
            
            logger.info(f"üîÑ Executando compra via WebSocket - Session: {self.session_id}")
            logger.info(f"üìã Par√¢metros: {buy_message}")
            
            response = await self._send_request(buy_message)
            
            if 'error' in response:
                raise Exception(f"Deriv API Error: {response['error']['message']}")
            
            logger.info(f"‚úÖ Compra executada com sucesso via WebSocket")
            return response
            
        except Exception as e:
            logger.error(f"‚ùå Erro na compra via WebSocket: {e}")
            raise e
    
    async def ticks_history(self, symbol: str, count: int = 5):
        """Obt√©m hist√≥rico de ticks usando WebSocket nativo"""
        await self.ensure_connection()
        
        try:
            # Estrutura de ticks_history conforme documenta√ß√£o Deriv
            ticks_message = {
                "ticks_history": symbol,
                "count": count,
                "end": "latest"
            }
            
            logger.debug(f"üìä Solicitando hist√≥rico de ticks: {ticks_message}")
            
            response = await self._send_request(ticks_message)
            
            if 'error' in response:
                raise Exception(f"Deriv API Error: {response['error']['message']}")
            
            return response
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao obter ticks via WebSocket: {e}")
            raise e
    
    async def proposal_open_contract(self, contract_id: str):
        """Obt√©m informa√ß√µes do contrato usando WebSocket nativo"""
        await self.ensure_connection()
        
        try:
            # Estrutura de proposal_open_contract conforme documenta√ß√£o Deriv
            contract_message = {
                "proposal_open_contract": 1,
                "contract_id": contract_id
            }
            
            logger.debug(f"üìã Solicitando informa√ß√µes do contrato: {contract_message}")
            
            response = await self._send_request(contract_message)
            
            if 'error' in response:
                raise Exception(f"Deriv API Error: {response['error']['message']}")
            
            return response
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao obter contrato via WebSocket: {e}")
            raise e
    
    async def proposal(self, params):
        """Executa proposta usando WebSocket nativo"""
        await self.ensure_connection()
        
        try:
            # Estrutura de proposta conforme documenta√ß√£o Deriv
            proposal_message = {
                "proposal": 1,
                "contract_type": "ACCU",
                "symbol": str(params["symbol"]),
                "amount": float(params["amount"]),
                "basis": "stake",
                "currency": "USD",
                "growth_rate": float(params["growth_rate"])
            }
            
            # Adicionar limit_order se presente
            if "limit_order" in params:
                proposal_message["limit_order"] = params["limit_order"]
            
            logger.info(f"üîÑ Executando proposta via WebSocket - Session: {self.session_id}")
            logger.info(f"üìã Par√¢metros: {proposal_message}")
            
            response = await self._send_request(proposal_message)
            
            if 'error' in response:
                raise Exception(f"Deriv API Error: {response['error']['message']}")
            
            logger.info(f"‚úÖ Proposta executada com sucesso via WebSocket")
            return response
            
        except Exception as e:
            logger.error(f"‚ùå Erro na proposta via WebSocket: {e}")
            raise e
    
    async def _process_tick(self, tick_data):
        """Processa tick recebido em tempo real"""
        try:
            if hasattr(self, 'bot_instance') and self.bot_instance:
                await self.bot_instance._handle_new_tick(tick_data)
        except Exception as e:
            self.error_handler.handle_error(e, ErrorType.TICK_PROCESSING, ErrorSeverity.HIGH)
            logger.error(f"‚ùå Erro ao processar tick: {e}")
    
    async def subscribe_ticks(self, symbol: str):
        """Inicia subscription de ticks em tempo real"""
        await self.ensure_connection()
        
        try:
            # Estrutura de subscription conforme documenta√ß√£o Deriv
            tick_message = {
                "ticks": symbol,
                "subscribe": 1
            }
            
            logger.info(f"üìä Iniciando subscription de ticks para {symbol}")
            
            response = await self._send_request(tick_message)
            
            if 'error' in response:
                raise Exception(f"Deriv API Error: {response['error']['message']}")
            
            logger.info(f"‚úÖ Subscription de ticks ativa para {symbol}")
            return response
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao iniciar subscription de ticks: {e}")
            raise e
    
    def set_bot_instance(self, bot_instance):
        """Define a inst√¢ncia do bot para callback de ticks"""
        self.bot_instance = bot_instance
    
    async def portfolio(self, params=None):
        """Obt√©m portfolio de contratos ativos usando WebSocket nativo"""
        await self.ensure_connection()
        
        try:
            # Estrutura de portfolio conforme documenta√ß√£o Deriv
            portfolio_message = {
                "portfolio": 1
            }
            
            logger.debug(f"üìä Solicitando portfolio: {portfolio_message}")
            
            response = await self._send_request(portfolio_message)
            
            if 'error' in response:
                raise Exception(f"Deriv API Error: {response['error']['message']}")
            
            return response
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao obter portfolio via WebSocket: {e}")
            raise e
    
    async def disconnect(self):
        """Desconecta adequadamente o WebSocket"""
        logger.info("üîå Desconectando WebSocket...")
        
        self.connected = False
        self.authorized = False
        
        # Limpar requests pendentes
        for req_id, future in self.pending_requests.items():
            if not future.done():
                future.cancel()
        self.pending_requests.clear()
        
        if hasattr(self, 'account_manager') and self.account_manager:
            try:
                await self.account_manager.connection_manager.close()
                logger.info("‚úÖ WebSocket desconectado com sucesso")
            except Exception as e:
                logger.error(f"‚ùå Erro ao desconectar WebSocket: {e}")
        
        self.account_manager = None
        self.session_id = None

# ============================================================================
# CLASSE PRINCIPAL DO BOT ACCUMULATOR
# ============================================================================
class AccumulatorScalpingBot:
    """Bot Accumulator Scalping com l√≥gica fiel ao XML e resili√™ncia a falhas"""
    
    def __init__(self, config, account_manager: ThunderBotAccountManager):
        # Sistema de tratamento de erros
        self.error_handler = RobustErrorHandler(NOME_BOT)
        
        # Configura√ß√£o e gerenciador de conta
        self.config = config
        self.account_manager = account_manager
        self.account_name = account_manager.account_name
        
        # Manter compatibilidade com c√≥digo existente
        self.api_manager = account_manager.connection_manager
        self.ativo = ATIVO
        
        # VARI√ÅVEIS CONFORME XML ORIGINAL
        self.stake = STAKE_INICIAL  # Stake (vari√°vel)
        self.initial_stake = STAKE_INICIAL  # initial stake (constante)
        self.total_lost = 0.0  # total lost
        self.khizzbot = KHIZZBOT  # khizzbot = 50
        self.account_initial_take_profit = STAKE_INICIAL * TAKE_PROFIT_PERCENTUAL  # DT inicial
        self.dt = self.account_initial_take_profit  # DT (take profit din√¢mico)
        
        # Controles de parada
        self.win_stop = WIN_STOP
        self.loss_limit = LOSS_LIMIT
        self.total_profit = 0.0  # Lucro total acumulado
        
        self.ticks_history = []
        self.ciclo = 0
        
        # NOVO: Sistema de tick stream em tempo real
        self.tick_buffer = []  # Buffer para manter √∫ltimos 5 ticks
        self.tick_subscription_active = False  # Flag para controlar subscription
        
        # NOVO: Sistema robusto de execu√ß√£o de ordens
        self.robust_order_system = RobustOrderSystem(self.api_manager)
        
        # NOVO: Sistema de sincroniza√ß√£o aprimorado
        self.sync_system = EnhancedSyncSystem(max_concurrent_operations=2, max_queue_size=3)
        
        # NOVO: Sistemas Avan√ßados Integrados
        self.enhanced_tick_buffer = EnhancedTickBuffer(max_size=10, tolerance_seconds=1.0)
        self.websocket_recovery = WebSocketRecoveryManager(max_retries=5, base_delay=2.0)
        self.signal_queue = ThreadSafeSignalQueue(max_size=10, max_concurrent=2)
        self.health_monitor = SystemHealthMonitor(
            deadlock_threshold=120.0,
            inactivity_threshold=180.0,
            high_failure_rate=0.7,
            min_operations_for_rate_check=10
        )
        
        # Cache de par√¢metros pr√©-validados
        self._cached_params = None
        self._params_cache_time = 0
        self._params_cache_ttl = 5.0  # 5 segundos
        
        # Sistema de debugging avan√ßado
        self._signal_history = []
        self._max_signal_history = 100
        self._debug_log_file = f"debug_signals_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        
        # Sistema de monitoramento de inatividade
        self._last_operation_time = time.time()  # Timestamp da √∫ltima opera√ß√£o
        self._inactivity_timeout = 120  # 2 minutos em segundos
        self._restart_in_progress = False  # Flag para evitar m√∫ltiplos restarts
        self._operation_count = 0  # Contador de opera√ß√µes executadas
        
        # Configurar callbacks de recupera√ß√£o do health monitor
        self.health_monitor.set_recovery_callbacks(
            on_connection_issues=self._reconnect_and_resubscribe,
            on_system_restart=self._force_restart_bot
        )
        
        logger.info(f"ü§ñ {NOME_BOT} inicializado")
        logger.info(f"üìä Configura√ß√£o XML:")
        logger.info(f"   ‚Ä¢ Ativo: {ATIVO}")
        logger.info(f"   ‚Ä¢ Initial Stake: ${self.initial_stake}")
        logger.info(f"   ‚Ä¢ Stake Atual: ${self.stake}")
        logger.info(f"   ‚Ä¢ Take Profit %: {TAKE_PROFIT_PERCENTUAL*100}%")
        logger.info(f"   ‚Ä¢ Growth Rate: {GROWTH_RATE*100}%")
        logger.info(f"   ‚Ä¢ Khizzbot: {self.khizzbot}")
        logger.info(f"   ‚Ä¢ Win Stop: ${self.win_stop}")
        logger.info(f"   ‚Ä¢ Loss Limit: ${self.loss_limit}")
        logger.info(f"üîß Sistemas Avan√ßados Integrados:")
        logger.info(f"   ‚Ä¢ Enhanced Tick Buffer: ‚úÖ (max_size=10)")
        logger.info(f"   ‚Ä¢ WebSocket Recovery: ‚úÖ (max_retries=5)")
        logger.info(f"   ‚Ä¢ Signal Queue: ‚úÖ (max_size=10, max_concurrent=2)")
        logger.info(f"   ‚Ä¢ Health Monitor: ‚úÖ (check_interval=30s)")
    
    @with_error_handling(ErrorType.DATA_PROCESSING, ErrorSeverity.HIGH)
    async def _handle_new_tick(self, tick_data):
        """Processa novo tick recebido em tempo real com sistema de queue"""
        try:
            # Timestamp preciso para debugging
            tick_timestamp = time.time()
            
            # Extrair valor do tick
            tick_value = float(tick_data.get('quote', 0))
            
            if tick_value <= 0:
                logger.warning(f"‚ö†Ô∏è Tick inv√°lido recebido: {tick_data}")
                return
            
            # Log detalhado com timestamp preciso
            logger.debug(f"üì• TICK_RECEIVED: {tick_value:.5f} at {tick_timestamp:.6f}")
            
            # Adicionar ao buffer
            self.tick_buffer.append(tick_value)
            
            # Manter apenas os √∫ltimos 5 ticks
            if len(self.tick_buffer) > 5:
                self.tick_buffer.pop(0)  # Remove o mais antigo
            
            # Executar an√°lise quando tiver 5 ticks
            if len(self.tick_buffer) == 5:
                pattern_detected = self.analisar_padrao_entrada(self.tick_buffer.copy())
                
                if pattern_detected:
                    logger.info(f"üéØ PATTERN_DETECTED at {tick_timestamp:.6f}")
                
                # Salvar sinal no hist√≥rico de debugging
                self._save_signal_to_history(self.tick_buffer.copy(), pattern_detected)
                
                # Enviar sinal para queue (sempre, mesmo sem padr√£o para estat√≠sticas)
                success = self.sync_system.queue_signal(self.tick_buffer.copy(), pattern_detected)
                
                if success:
                    logger.debug(f"üì§ SIGNAL_QUEUED: pattern={pattern_detected} at {tick_timestamp:.6f}")
                else:
                    logger.warning(f"‚ö†Ô∏è Falha ao enfileirar sinal at {tick_timestamp:.6f}")
                
        except Exception as e:
            logger.error(f"‚ùå Erro ao processar tick: {e}")
    
    async def _process_signals_from_queue(self):
        """Processa sinais da queue de forma ass√≠ncrona"""
        while True:
            try:
                # Obter pr√≥ximo sinal da queue (n√£o bloqueante)
                signal = self.sync_system.get_next_signal()
                
                if signal and signal.pattern_detected:
                    operation_timestamp = time.time()
                    logger.info(f"üöÄ OPERATION_QUEUED at {operation_timestamp:.6f}")
                    
                    # Verificar se pode executar opera√ß√£o
                    if self.sync_system.can_execute_operation():
                        # Adquirir sem√°foro para opera√ß√£o
                        async with self.sync_system.operation_semaphore:
                            try:
                                logger.info(f"‚ö° OPERATION_EXECUTING at {time.time():.6f}")
                                
                                # Executar compra
                                contract_id = await self.executar_compra_accu()
                                
                                if contract_id:
                                    logger.info(f"‚úÖ OPERATION_SUCCESS at {time.time():.6f}")
                                    self.sync_system.record_operation_success()
                                    
                                    # Monitorar contrato
                                    lucro = await self.monitorar_contrato(contract_id)
                                    
                                    # Aplicar gest√£o de risco
                                    self.aplicar_gestao_risco(lucro)
                                else:
                                    logger.error(f"‚ùå OPERATION_FAILED at {time.time():.6f}")
                                    self.sync_system.record_operation_failure()
                                    
                            except Exception as e:
                                logger.error(f"‚ùå Erro durante execu√ß√£o da compra: {e}")
                                self.sync_system.record_operation_failure()
                    else:
                        logger.warning(f"‚ö†Ô∏è Opera√ß√£o rejeitada - limite de opera√ß√µes simult√¢neas atingido")
                
                # Pequeno delay para evitar loop intensivo
                await asyncio.sleep(0.1)
                
            except Exception as e:
                logger.error(f"‚ùå Erro no processamento de sinais: {e}")
                await asyncio.sleep(1)
        
        # Validar configura√ß√£o inicial
        self._validar_configuracao_inicial()
    
    def _pre_validate_params(self):
        """Pr√©-valida par√¢metros para otimiza√ß√£o de lat√™ncia"""
        current_time = time.time()
        
        # Verificar se cache ainda √© v√°lido
        if (self._cached_params and 
            current_time - self._params_cache_time < self._params_cache_ttl):
            return self._cached_params
        
        try:
            # Validar par√¢metros ACCU
            params = {
                'contract_type': 'ACCU',
                'symbol': ATIVO,
                'currency': 'USD',
                'amount': float(STAKE_INICIAL),
                'growth_rate': float(GROWTH_RATE),
                'take_profit': float(TAKE_PROFIT_PERCENTUAL)
            }
            
            # Valida√ß√µes b√°sicas
            if params['amount'] <= 0:
                raise ValueError(f"Stake inv√°lido: {params['amount']}")
            
            if not (0.01 <= params['growth_rate'] <= 0.05):
                raise ValueError(f"Growth rate inv√°lido: {params['growth_rate']}")
            
            if not (0.01 <= params['take_profit'] <= 1.0):
                raise ValueError(f"Take profit inv√°lido: {params['take_profit']}")
            
            # Atualizar cache
            self._cached_params = params
            self._params_cache_time = current_time
            
            logger.debug(f"‚úÖ Par√¢metros pr√©-validados e cacheados")
            return params
            
        except Exception as e:
            logger.error(f"‚ùå Erro na pr√©-valida√ß√£o de par√¢metros: {e}")
            return None
    
    async def _real_time_monitoring(self):
        """Monitoramento em tempo real com logs estruturados e detec√ß√£o de problemas"""
        deadlock_start_time = None
        connection_error_start_time = None
        last_successful_operation_time = time.time()
        error_threshold = 120  # 2 minutos em segundos
        
        while True:
            try:
                # Log estruturado a cada 30 segundos
                stats = self.sync_system.get_statistics()
                current_time = time.time()
                
                last_signal_str = f"{stats['last_signal_time']:.6f}" if stats['last_signal_time'] else "None"
                
                logger.info(f"üìä STATUS_REPORT: "
                          f"queue_size={stats['queue_size']}, "
                          f"active_operations={stats['active_operations']}, "
                          f"circuit_breaker={stats['circuit_breaker_state']}, "
                          f"last_signal={last_signal_str}, "
                          f"total_signals={stats['total_signals_processed']}, "
                          f"successful_operations={stats['successful_operations']}, "
                          f"failed_operations={stats['failed_operations']}")
                
                # Atualizar tempo da √∫ltima opera√ß√£o bem-sucedida
                if stats['successful_operations'] > 0:
                    last_successful_operation_time = current_time
                
                # 1. Detec√ß√£o de deadlock: queue cheia + sem opera√ß√µes ativas
                is_deadlocked = (stats['queue_size'] >= 3 and stats['active_operations'] == 0)
                
                # 2. Detec√ß√£o de problemas de conex√£o/opera√ß√£o
                total_operations = stats['successful_operations'] + stats['failed_operations']
                failure_rate = stats['failed_operations'] / max(total_operations, 1)
                
                connection_issues = (
                    # WebSocket realmente desconectado
                    (hasattr(self.api_manager, 'websocket') and 
                     self.api_manager.websocket is not None and 
                     self.api_manager.websocket.closed) or
                    # Circuit breaker aberto por muito tempo
                    stats['circuit_breaker_state'] == 'OPEN' or
                    # Taxa de falha muito alta (>70%) com pelo menos 10 opera√ß√µes
                    (total_operations >= 10 and failure_rate > 0.7) or
                    # Sem opera√ß√µes bem-sucedidas h√° muito tempo (apenas se j√° houve opera√ß√µes)
                    (total_operations > 0 and (current_time - last_successful_operation_time) > 600)  # 10 minutos
                )
                
                # 3. Verificar lat√™ncia da conex√£o
                high_latency = False
                if hasattr(self.api_manager, 'last_ping_time'):
                    latency = current_time - self.api_manager.last_ping_time
                    if latency > 2.0:  # Lat√™ncia > 2s
                        high_latency = True
                        logger.warning(f"‚ö†Ô∏è Alta lat√™ncia detectada: {latency:.3f}s")
                
                # Detectar qualquer problema cr√≠tico
                critical_issue = is_deadlocked or connection_issues or high_latency
                
                if critical_issue:
                    # Identificar tipo de problema
                    problem_type = []
                    if is_deadlocked:
                        problem_type.append("DEADLOCK")
                    if connection_issues:
                        problem_type.append("CONNECTION_ISSUES")
                    if high_latency:
                        problem_type.append("HIGH_LATENCY")
                    
                    if deadlock_start_time is None:
                        deadlock_start_time = current_time
                        logger.warning(f"‚ö†Ô∏è PROBLEMA CR√çTICO DETECTADO: {', '.join(problem_type)} - iniciando contagem de {error_threshold}s")
                        logger.warning(f"   Detalhes: queue_size={stats['queue_size']}, active_operations={stats['active_operations']}, "
                                     f"circuit_breaker={stats['circuit_breaker_state']}, failed_ops={stats['failed_operations']}")
                    else:
                        problem_duration = current_time - deadlock_start_time
                        logger.warning(f"‚ö†Ô∏è PROBLEMA ATIVO h√° {problem_duration:.1f}s - limite: {error_threshold}s - Tipos: {', '.join(problem_type)}")
                        
                        if problem_duration >= error_threshold:
                            logger.error(f"üîÑ PROBLEMA CR√çTICO: Reiniciando bot ap√≥s {problem_duration:.1f}s - Tipos: {', '.join(problem_type)}")
                            # For√ßar reinicializa√ß√£o do sistema
                            await self._force_restart_bot()
                            return  # Sair do loop de monitoramento
                else:
                    # Reset do contador se a situa√ß√£o foi resolvida
                    if deadlock_start_time is not None:
                        logger.info(f"‚úÖ PROBLEMAS RESOLVIDOS: queue_size={stats['queue_size']}, active_operations={stats['active_operations']}, "
                                  f"circuit_breaker={stats['circuit_breaker_state']}")
                        deadlock_start_time = None
                
                await asyncio.sleep(30)  # Log a cada 30 segundos
                
            except Exception as e:
                 logger.error(f"‚ùå Erro no monitoramento em tempo real: {e}")
                 # Se houver erro no pr√≥prio monitoramento, tamb√©m considerar reiniciar
                 if connection_error_start_time is None:
                     connection_error_start_time = time.time()
                 elif (time.time() - connection_error_start_time) > 180:  # 3 minutos de erros
                     logger.error(f"üîÑ ERRO PERSISTENTE NO MONITORAMENTO: Reiniciando bot")
                     await self._force_restart_bot()
                     return
                 await asyncio.sleep(30)
    
    async def _status_handler(self, request):
        """Handler para endpoint /status"""
        try:
            stats = self.sync_system.get_statistics()
            
            status_data = {
                'timestamp': time.time(),
                'bot_name': NOME_BOT,
                'active': True,
                'circuit_breaker_state': stats['circuit_breaker_state'],
                'active_operations': stats['active_operations'],
                'queue_size': stats['queue_size'],
                'last_signal_time': stats['last_signal_time'],
                'total_signals': stats['total_signals'],
                'successful_operations': stats['successful_operations'],
                'failed_operations': stats['failed_operations'],
                'tick_buffer_size': len(self.tick_buffer),
                'connection_status': self.api_manager.connected if hasattr(self, 'api_manager') else False,
                'subscription_active': self.tick_subscription_active,
                'cached_params_valid': (time.time() - self._params_cache_time) < self._params_cache_ttl if self._cached_params else False
            }
            
            return web.json_response(status_data)
            
        except Exception as e:
            logger.error(f"‚ùå Erro no endpoint /status: {e}")
            return web.json_response({'error': str(e)}, status=500)
    
    async def _start_http_server(self):
        """Inicia servidor HTTP para endpoint /status"""
        try:
            app = web.Application()
            app.router.add_get('/status', self._status_handler)
            
            runner = web.AppRunner(app)
            await runner.setup()
            
            site = web.TCPSite(runner, 'localhost', 8080)
            await site.start()
            
            logger.info("üåê Servidor HTTP iniciado em http://localhost:8080/status")
            
        except Exception as e:
             logger.error(f"‚ùå Erro ao iniciar servidor HTTP: {e}")
    
    async def _force_restart_bot(self):
        """For√ßa reinicializa√ß√£o completa do bot em caso de deadlock cr√≠tico"""
        try:
            logger.error("üîÑ INICIANDO REINICIALIZA√á√ÉO FOR√áADA DO BOT...")
            
            # 1. Parar processamento de sinais
            self.running = False
            logger.info("‚úÖ Processamento de sinais interrompido")
            
            # 2. Limpar queue de sinais
            await self.sync_system.clear_signal_queue()
            logger.info("‚úÖ Queue de sinais limpa")
            
            # 3. Reset do circuit breaker
            self.robust_order_system.reset_circuit_breaker()
            logger.info("‚úÖ Circuit breaker resetado")
            
            # 4. Desconectar WebSocket com timeout
            if hasattr(self, 'api_manager') and self.api_manager:
                try:
                    await asyncio.wait_for(self.api_manager.disconnect(), timeout=10.0)
                    logger.info("‚úÖ WebSocket desconectado")
                except asyncio.TimeoutError:
                    logger.warning("‚ö†Ô∏è Timeout na desconex√£o WebSocket - continuando...")
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è Erro na desconex√£o WebSocket: {e} - continuando...")
            
            # 5. Aguardar limpeza completa
            await asyncio.sleep(8)
            
            # 6. Reinicializar componentes
            self.api_manager = DerivWebSocketNativo()
            self.api_manager.set_bot_instance(self)
            logger.info("‚úÖ API Manager reinicializado")
            
            # 7. Reconectar com retry e timeout
            max_retries = 3
            for attempt in range(max_retries):
                try:
                    logger.info(f"üîó Tentativa {attempt + 1}/{max_retries} de reconex√£o...")
                    await asyncio.wait_for(self.api_manager.connect(), timeout=15.0)
                    await asyncio.sleep(2)  # Aguardar estabiliza√ß√£o
                    
                    await asyncio.wait_for(self.api_manager.subscribe_ticks(ATIVO), timeout=10.0)
                    logger.info("‚úÖ Reconectado e resubscrito aos ticks")
                    break
                    
                except asyncio.TimeoutError:
                    logger.warning(f"‚ö†Ô∏è Timeout na tentativa {attempt + 1} - tentando novamente...")
                    if attempt < max_retries - 1:
                        await asyncio.sleep(5)
                    else:
                        raise Exception("Falha na reconex√£o ap√≥s m√∫ltiplas tentativas")
                        
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è Erro na tentativa {attempt + 1}: {e}")
                    if attempt < max_retries - 1:
                        await asyncio.sleep(5)
                    else:
                        raise
            
            # 8. Reiniciar processamento
            self.running = True
            logger.info("‚úÖ Processamento de sinais reiniciado")
            
            # 9. Reiniciar tarefas ass√≠ncronas
            asyncio.create_task(self._process_signals_from_queue())
            asyncio.create_task(self._real_time_monitoring())
            
            logger.error("üîÑ REINICIALIZA√á√ÉO FOR√áADA CONCLU√çDA COM SUCESSO")
            
        except Exception as e:
            logger.error(f"‚ùå ERRO CR√çTICO na reinicializa√ß√£o for√ßada: {e}")
            # Em caso de falha cr√≠tica, encerrar o processo
            logger.error("üíÄ ENCERRANDO PROCESSO - Falha na recupera√ß√£o autom√°tica")
            os._exit(1)
    
    async def _check_inactivity_and_restart(self):
        """Verifica inatividade e reinicia o bot se necess√°rio"""
        try:
            current_time = time.time()
            time_since_last_operation = current_time - self._last_operation_time
            
            # Log de monitoramento a cada 30 segundos
            if int(time_since_last_operation) % 30 == 0 and int(time_since_last_operation) > 0:
                logger.info(f"‚è±Ô∏è Tempo desde √∫ltima opera√ß√£o: {int(time_since_last_operation)}s (limite: {self._inactivity_timeout}s)")
            
            # Verificar se excedeu o timeout de inatividade
            if time_since_last_operation > self._inactivity_timeout and not self._restart_in_progress:
                logger.warning(f"‚ö†Ô∏è INATIVIDADE DETECTADA: {int(time_since_last_operation)}s sem opera√ß√µes")
                logger.warning(f"üîÑ Iniciando rein√≠cio autom√°tico do bot...")
                
                self._restart_in_progress = True
                
                # Executar restart
                restart_success = await self._force_restart_bot()
                
                if restart_success:
                    # Resetar timestamp e contador
                    self._last_operation_time = time.time()
                    self._operation_count = 0
                    logger.info("‚úÖ Bot reiniciado com sucesso ap√≥s inatividade")
                else:
                    logger.error("‚ùå Falha no rein√≠cio autom√°tico")
                
                self._restart_in_progress = False
                
        except Exception as e:
            logger.error(f"‚ùå Erro no monitoramento de inatividade: {e}")
            self._restart_in_progress = False
    
    def _update_operation_timestamp(self):
        """Atualiza o timestamp da √∫ltima opera√ß√£o"""
        self._last_operation_time = time.time()
        self._operation_count += 1
        logger.debug(f"üìä Opera√ß√£o #{self._operation_count} registrada √†s {datetime.now().strftime('%H:%M:%S')}")
    
    def _save_signal_to_history(self, signal_data, pattern_detected, operation_result=None):
        """Salva sinal no hist√≥rico para debugging"""
        try:
            timestamp_precise = time.time()
            
            signal_record = {
                'timestamp': timestamp_precise,
                'timestamp_readable': datetime.fromtimestamp(timestamp_precise).strftime('%Y-%m-%d %H:%M:%S.%f'),
                'ticks': signal_data.copy() if signal_data else [],
                'pattern_detected': pattern_detected,
                'operation_result': operation_result,
                'queue_size_at_time': self.sync_system.get_statistics()['queue_size'],
                'active_operations_at_time': self.sync_system.get_statistics()['active_operations']
            }
            
            # Adicionar ao hist√≥rico
            self._signal_history.append(signal_record)
            
            # Manter apenas os √∫ltimos 100 sinais
            if len(self._signal_history) > self._max_signal_history:
                self._signal_history.pop(0)
            
            # Salvar em arquivo JSON a cada 10 sinais
            if len(self._signal_history) % 10 == 0:
                self._save_history_to_file()
            
            # Log detalhado com timestamp preciso
            logger.debug(f"üîç SIGNAL_SAVED: timestamp={timestamp_precise:.6f}, "
                        f"pattern={pattern_detected}, ticks={len(signal_data) if signal_data else 0}")
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao salvar sinal no hist√≥rico: {e}")
    
    def _save_history_to_file(self):
        """Salva hist√≥rico de sinais em arquivo JSON"""
        try:
            with open(self._debug_log_file, 'w', encoding='utf-8') as f:
                json.dump({
                    'bot_name': NOME_BOT,
                    'created_at': datetime.now().isoformat(),
                    'total_signals': len(self._signal_history),
                    'signals': self._signal_history
                }, f, indent=2, ensure_ascii=False)
            
            logger.debug(f"üíæ Hist√≥rico salvo: {len(self._signal_history)} sinais em {self._debug_log_file}")
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao salvar hist√≥rico em arquivo: {e}")
    
    def _get_enhanced_stats(self) -> Dict[str, Any]:
        """Retorna estat√≠sticas detalhadas de todos os sistemas integrados"""
        try:
            # Stats do Enhanced Tick Buffer
            buffer_stats = self.enhanced_tick_buffer.get_buffer_stats()
            
            # Stats do WebSocket Recovery
            recovery_stats = self.websocket_recovery.get_connection_stats()
            
            # Stats da Signal Queue
            queue_stats = self.signal_queue.get_queue_stats()
            
            # Stats do Health Monitor
            health_summary = self.health_monitor.get_health_report()
            
            return {
                'timestamp': datetime.now().isoformat(),
                'bot_name': NOME_BOT,
                'operation_count': self._operation_count,
                'total_profit': self.total_profit,
                'current_stake': self.stake,
                'buffer_size': buffer_stats.get('current_size', 0),
                'buffer_capacity': buffer_stats.get('max_size', 0),
                'buffer_hit_rate': buffer_stats.get('hit_rate', 0.0),
                'recovery_attempts': recovery_stats.get('total_attempts', 0),
                'recovery_successes': recovery_stats.get('successful_recoveries', 0),
                'queue_size': queue_stats.get('current_size', 0),
                'queue_processed': queue_stats.get('total_processed', 0),
                'queue_errors': queue_stats.get('total_errors', 0),
                'health_score': health_summary.get('overall_health_score', 0.0),
                'system_uptime': health_summary.get('uptime_seconds', 0),
                'last_check': health_summary.get('last_check_time', 'N/A'),
                'active_alerts': len(health_summary.get('active_alerts', []))
            }
        except Exception as e:
            logger.error(f"‚ùå Erro ao obter estat√≠sticas: {e}")
            return {'error': str(e), 'timestamp': datetime.now().isoformat()}
    
    def test_enhanced_systems(self) -> Dict[str, Any]:
        """Testa todos os sistemas avan√ßados integrados"""
        test_results = {
            'timestamp': datetime.now().isoformat(),
            'bot_name': NOME_BOT,
            'tests': {}
        }
        
        try:
            # Teste Enhanced Tick Buffer
            test_tick_value = 1.23456
            self.enhanced_tick_buffer.add_tick(test_tick_value)
            buffer_test = self.enhanced_tick_buffer.get_last_n_ticks(1)
            buffer_stats = self.enhanced_tick_buffer.get_buffer_stats()
            test_results['tests']['enhanced_tick_buffer'] = {
                'status': 'PASS' if len(buffer_test) > 0 else 'FAIL',
                'details': f'Buffer size: {len(buffer_test)}, Stats: {buffer_stats}'
            }
            
            # Teste Signal Queue
            test_ticks = [1.23456, 1.23457, 1.23458]
            queue_added = self.signal_queue.queue_signal(test_ticks, True)
            queue_stats = self.signal_queue.get_queue_stats()
            test_results['tests']['signal_queue'] = {
                'status': 'PASS' if queue_added else 'FAIL',
                'details': f'Queue size: {queue_stats["current_size"]}, Stats: {queue_stats}'
            }
            
            # Teste WebSocket Recovery
            recovery_stats = self.websocket_recovery.get_connection_stats()
            test_results['tests']['websocket_recovery'] = {
                'status': 'PASS',
                'details': f'Recovery manager initialized, state: {recovery_stats.get("state", "unknown")}'
            }
            
            # Teste Health Monitor
            health_report = self.health_monitor.get_health_report()
            test_results['tests']['health_monitor'] = {
                'status': 'PASS',
                'details': f'Health status: {health_report.get("current_status", "unknown")}'
            }
            
            # Teste Enhanced Stats
            enhanced_stats = self._get_enhanced_stats()
            test_results['tests']['enhanced_stats'] = {
                'status': 'PASS' if 'error' not in enhanced_stats else 'FAIL',
                'details': f'Stats fields: {len(enhanced_stats)}'
            }
            
            # Resumo geral
            passed_tests = sum(1 for test in test_results['tests'].values() if test['status'] == 'PASS')
            total_tests = len(test_results['tests'])
            test_results['summary'] = {
                'total_tests': total_tests,
                'passed': passed_tests,
                'failed': total_tests - passed_tests,
                'success_rate': f'{(passed_tests/total_tests)*100:.1f}%'
            }
            
            logger.info(f"üß™ Teste dos sistemas avan√ßados: {passed_tests}/{total_tests} PASS")
            
        except Exception as e:
            test_results['error'] = str(e)
            logger.error(f"‚ùå Erro durante teste dos sistemas: {e}")
        
        return test_results
    
    def _validar_configuracao_inicial(self):
        """Valida a configura√ß√£o inicial do bot"""
        logger.info("üîç VALIDANDO CONFIGURA√á√ÉO INICIAL...")
        
        # Validar GROWTH_RATE
        if GROWTH_RATE < 0.01 or GROWTH_RATE > 0.05:
            raise ValueError(f"‚ùå GROWTH_RATE inv√°lido: {GROWTH_RATE*100}% (deve ser 1-5%)")
        
        # Validar ATIVO
        if not ATIVO or not isinstance(ATIVO, str):
            raise ValueError(f"‚ùå ATIVO inv√°lido: {ATIVO}")
        
        # Validar STAKE_INICIAL
        if STAKE_INICIAL < 0.35 or STAKE_INICIAL > 50000:
            raise ValueError(f"‚ùå STAKE_INICIAL inv√°lido: ${STAKE_INICIAL} (deve ser $0.35-$50,000)")
        
        # Validar TAKE_PROFIT_PERCENTUAL
        if TAKE_PROFIT_PERCENTUAL <= 0 or TAKE_PROFIT_PERCENTUAL > 1:
            raise ValueError(f"‚ùå TAKE_PROFIT_PERCENTUAL inv√°lido: {TAKE_PROFIT_PERCENTUAL*100}%")
        
        logger.info("‚úÖ Configura√ß√£o inicial validada com sucesso!")
    
    def _validar_parametros_accu(self, params: Dict[str, Any]) -> bool:
        """Valida se os par√¢metros do contrato ACCU est√£o corretos"""
        required_keys = ["proposal", "contract_type", "symbol", "amount", "basis", "currency", "growth_rate"]
        
        # Verificar se todas as chaves obrigat√≥rias est√£o presentes
        if not all(key in params for key in required_keys):
            missing_keys = [key for key in required_keys if key not in params]
            logger.error(f"‚ùå Chaves obrigat√≥rias ausentes: {missing_keys}")
            return False
        
        # Verificar valores espec√≠ficos
        if params.get("contract_type") != "ACCU":
            logger.error(f"‚ùå Contract type deve ser 'ACCU', recebido: {params.get('contract_type')}")
            return False
        
        if params.get("basis") != "stake":
            logger.error(f"‚ùå Basis deve ser 'stake', recebido: {params.get('basis')}")
            return False
        
        # CORRE√á√ÉO CR√çTICA: Aceitar tanto float quanto string para growth_rate
        growth_rate = params.get("growth_rate")
        if growth_rate is None:
            logger.error(f"‚ùå Growth rate ausente")
            return False
            
        # Converter para float se for string
        try:
            if isinstance(growth_rate, str):
                growth_rate_float = float(growth_rate)
            else:
                growth_rate_float = float(growth_rate)
                
            if growth_rate_float < 0.01 or growth_rate_float > 0.05:
                logger.error(f"‚ùå Growth rate deve ser entre 0.01 e 0.05, recebido: {growth_rate}")
                return False
        except (ValueError, TypeError):
            logger.error(f"‚ùå Growth rate inv√°lido: {growth_rate}")
            return False
        
        if not isinstance(params.get("amount"), (int, float)) or params.get("amount") < 0.35:
            logger.error(f"‚ùå Amount deve ser >= 0.35, recebido: {params.get('amount')}")
            return False
        
        logger.info("‚úÖ Par√¢metros ACCU validados com sucesso!")
        return True
    
    async def obter_ultimos_5_ticks(self) -> List[float]:
        """Obt√©m os √∫ltimos 5 ticks do ativo com tratamento robusto de erros"""
        max_retries = 3
        for attempt in range(max_retries):
            try:
                response = await self.api_manager.ticks_history(self.ativo, count=5)
                
                # A API retorna os dados em 'history' ao inv√©s de 'ticks_history'
                if 'history' in response and 'prices' in response['history']:
                    prices = response['history']['prices']
                    self.ticks_history = prices[-5:] if len(prices) >= 5 else prices
                    return self.ticks_history
                elif 'ticks_history' in response and 'prices' in response['ticks_history']:
                    prices = response['ticks_history']['prices']
                    self.ticks_history = prices[-5:] if len(prices) >= 5 else prices
                    return self.ticks_history
                else:
                    raise Exception(f"Resposta inv√°lida da API: {response}")
                    
            except Exception as e:
                logger.error(f"‚ùå Erro ao obter ticks (tentativa {attempt + 1}/{max_retries}): {e}")
                if attempt < max_retries - 1:
                    await asyncio.sleep(2)
                else:
                    raise Exception(f"Falha ao obter ticks ap√≥s {max_retries} tentativas: {e}")
    
    def debug_comparacao_xml_python(self, ticks: List[float]) -> Dict[str, Any]:
        """Fun√ß√£o de debug para comparar resultados XML vs Python"""
        if len(ticks) < 5:
            return {"erro": "Ticks insuficientes"}
            
        # SIMULA√á√ÉO DA L√ìGICA XML EXATA
        tick4 = ticks[-5]  # FROM_END 5 (mais antigo)
        tick3 = ticks[-4]  # FROM_END 4
        tick2 = ticks[-3]  # FROM_END 3
        tick1 = ticks[-2]  # FROM_END 2
        tick_atual = ticks[-1]  # Tick atual (mais recente)
        
        # C√°lculo dos sinais XML
        single4_xml = "Red" if tick4 > tick3 else "Blue"
        single3_xml = "Red" if tick3 > tick2 else "Blue"
        single2_xml = "Red" if tick2 > tick1 else "Blue"
        single1_xml = "Red" if tick1 > tick_atual else "Blue"
        
        # CORRE√á√ÉO CR√çTICA: Usar verifica√ß√£o individual das condi√ß√µes com operador AND
        # Condi√ß√£o de entrada XML: single1=Red E single2=Red E single3=Red E single4=Blue
        entrada_xml = (single1_xml == "Red" and 
                      single2_xml == "Red" and 
                      single3_xml == "Red" and 
                      single4_xml == "Blue")
        
        debug_info = {
            "ticks_raw": ticks,
            "tick_positions": {
                "tick4 (FROM_END 5)": tick4,
                "tick3 (FROM_END 4)": tick3,
                "tick2 (FROM_END 3)": tick2,
                "tick1 (FROM_END 2)": tick1,
                "tick_atual": tick_atual
            },
            "comparacoes": {
                "tick4 > tick3": f"{tick4:.5f} > {tick3:.5f} = {tick4 > tick3}",
                "tick3 > tick2": f"{tick3:.5f} > {tick2:.5f} = {tick3 > tick2}",
                "tick2 > tick1": f"{tick2:.5f} > {tick1:.5f} = {tick2 > tick1}",
                "tick1 > tick_atual": f"{tick1:.5f} > {tick_atual:.5f} = {tick1 > tick_atual}"
            },
            "sinais_xml": {
                "single1": single1_xml,
                "single2": single2_xml,
                "single3": single3_xml,
                "single4": single4_xml
            },
            "padrao_completo": [single1_xml, single2_xml, single3_xml, single4_xml],
            "padrao_esperado": "single1=Red E single2=Red E single3=Red E single4=Blue",
            "entrada_detectada": entrada_xml,
            "timestamp": datetime.now().strftime('%H:%M:%S.%f')[:-3]
        }
        
        return debug_info
    
    def analisar_padrao_entrada(self, ticks: List[float]) -> bool:
        """ 
        L√≥gica de Padr√£o XML: single1=Red E single2=Red E single3=Red E single4=Blue 
        Onde os sinais s√£o atribu√≠dos em ordem cronol√≥gica reversa mas verificados individualmente 
        """ 
        if len(ticks) < 5: 
            return False 
     
        # Atribui√ß√µes de tick do XML (indexa√ß√£o FROM_END) 
        tick4 = ticks[-5]  # FROM_END 5 (mais antigo) 
        tick3 = ticks[-4]  # FROM_END 4  
        tick2 = ticks[-3]  # FROM_END 3 
        tick1 = ticks[-2]  # FROM_END 2 
        tick_atual = ticks[-1]  # FROM_END 1 (atual/mais novo) 
     
        # C√°lculos de sinal do XML 
        single4 = "Red" if tick4 > tick3 else "Blue" 
        single3 = "Red" if tick3 > tick2 else "Blue"  
        single2 = "Red" if tick2 > tick1 else "Blue" 
        single1 = "Red" if tick1 > tick_atual else "Blue" 
     
        # Condi√ß√£o de entrada XML: todas as quatro condi√ß√µes devem ser True simultaneamente 
        entrada_xml = (single1 == "Red" and 
                       single2 == "Red" and 
                       single3 == "Red" and 
                       single4 == "Blue") 
     
        # Log detalhado para debug 
        logger.info(f"üìä VERIFICA√á√ÉO DE PADR√ÉO XML:") 
        logger.info(f"   ‚Ä¢ single1 (tick1 > atual): {single1} ({tick1:.5f} > {tick_atual:.5f})") 
        logger.info(f"   ‚Ä¢ single2 (tick2 > tick1): {single2} ({tick2:.5f} > {tick1:.5f})") 
        logger.info(f"   ‚Ä¢ single3 (tick3 > tick2): {single3} ({tick3:.5f} > {tick2:.5f})") 
        logger.info(f"   ‚Ä¢ single4 (tick4 > tick3): {single4} ({tick4:.5f} > {tick3:.5f})") 
        logger.info(f"   ‚Ä¢ Padr√£o esperado: single1=Red E single2=Red E single3=Red E single4=Blue") 
        logger.info(f"   ‚Ä¢ Entrada detectada: {entrada_xml}") 
     
        if entrada_xml:
            logger.info("üéØ PADR√ÉO DE ENTRADA DETECTADO! (XML MATCH)")
            logger.info("üöÄ EXECUTANDO COMPRA DO CONTRATO ACCUMULATOR...")
        else:
            logger.info("‚è≥ Aguardando padr√£o correto...")
            
        return entrada_xml
    
    async def log_to_supabase(self, operation_result: str, profit_percentage: float, stake_value: float):
        """Envia log de opera√ß√£o para Supabase"""
        try:
            supabase: Client = create_client(
                os.getenv('SUPABASE_URL'),
                os.getenv('SUPABASE_KEY')
            )
            
            # Adicionar timestamp fields obrigat√≥rios
            current_time = datetime.now().isoformat()
            
            data = {
                'operation_result': operation_result,
                'profit_percentage': profit_percentage,
                'stake_value': stake_value,
                'account_name': self.account_name,
                'bot_name': NOME_BOT,
                'created_at': current_time
            }
            
            result = supabase.table('tunder_bot_logs').insert(data).execute()
            logger.info(f"‚úÖ Log salvo no Supabase [{self.account_name}]: {operation_result} - Profit: {profit_percentage:.2f}% - Stake: ${stake_value}")
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao enviar log para Supabase [{self.account_name}]: {e}")
    
    @with_error_handling(ErrorType.TRADING, ErrorSeverity.CRITICAL)
    async def executar_compra_accu(self) -> Optional[str]:
        """Executa compra do contrato ACCU atrav√©s do account_manager"""
        
        # VALIDA√á√ÉO E LIMITA√á√ÉO DE STAKE (CORRE√á√ÉO CR√çTICA)
        # Validar e limitar stake conforme limite da Deriv API
        stake_para_usar = min(self.stake, STAKE_MAXIMO_DERIV)
        
        if stake_para_usar < self.stake:
            logger.warning(f"‚ö†Ô∏è Stake limitado: ${self.stake:.2f} -> ${stake_para_usar:.2f}")
        
        # VALIDA√á√ÉO DOS PAR√ÇMETROS ANTES DO ENVIO
        # 1. Validar stake m√≠nimo/m√°ximo
        if stake_para_usar < 0.35:
            logger.error(f"‚ùå Stake muito baixo: ${stake_para_usar} (m√≠nimo: $0.35)")
            return None
        if stake_para_usar > STAKE_MAXIMO_DERIV:
            logger.error(f"‚ùå Stake muito alto: ${stake_para_usar} (m√°ximo: ${STAKE_MAXIMO_DERIV})")
            return None
            
        # 2. Validar growth rate (1-5%)
        if GROWTH_RATE < 0.01 or GROWTH_RATE > 0.05:
            logger.error(f"‚ùå Growth rate inv√°lido: {GROWTH_RATE*100}% (deve ser 1-5%)")
            return None
            
        # 3. Validar par√¢metros obrigat√≥rios para ACCU
        if not ATIVO or not isinstance(ATIVO, str):
            logger.error(f"‚ùå S√≠mbolo inv√°lido: {ATIVO}")
            return None
            
        # 4. Validar take profit
        if self.dt <= 0:
            logger.error(f"‚ùå Take profit inv√°lido: ${self.dt}")
            return None
            
        # 3. Take profit: 10% do stake atual ($0.50 se stake=$5)
        take_profit_amount = self.stake * TAKE_PROFIT_PERCENTUAL
        
        # ESTRUTURA CORRETA BASEADA NA DOCUMENTA√á√ÉO OFICIAL DA DERIV API
        try:
            # ESTRUTURA CORRIGIDA CONFORME DOCUMENTA√á√ÉO OFICIAL DA DERIV
            required_params = {
                "proposal": 1,
                "contract_type": "ACCU",
                "symbol": ATIVO,
                "amount": float(stake_para_usar),  # USAR STAKE LIMITADO
                "basis": "stake",
                "currency": "USD",
                "growth_rate": GROWTH_RATE,
                "limit_order": {
                    "take_profit": float(take_profit_amount)  # CORRE√á√ÉO: 10% do stake
                }
            }
            
            # Validar par√¢metros usando fun√ß√£o especializada
            if not self._validar_parametros_accu(required_params):
                logger.error(f"‚ùå Valida√ß√£o dos par√¢metros ACCU falhou")
                return None
                
            # Log detalhado dos par√¢metros para debug
            logger.info(f"üìã PAR√ÇMETROS DA PROPOSTA ACCU:")
            logger.info(f"   ‚Ä¢ proposal: 1")
            logger.info(f"   ‚Ä¢ contract_type: ACCU")
            logger.info(f"   ‚Ä¢ symbol: {ATIVO}")
            logger.info(f"   ‚Ä¢ amount: {stake_para_usar}")
            logger.info(f"   ‚Ä¢ basis: stake")
            logger.info(f"   ‚Ä¢ currency: USD")
            logger.info(f"   ‚Ä¢ growth_rate: {GROWTH_RATE}")
            logger.info(f"   ‚Ä¢ limit_order.take_profit: {take_profit_amount}")
            
            logger.info(f"üí∞ EXECUTANDO COMPRA ACCU VIA ACCOUNT MANAGER:")
            logger.info(f"   ‚Ä¢ Stake: ${stake_para_usar}")
            logger.info(f"   ‚Ä¢ Take Profit (DT): ${take_profit_amount:.2f}")
            logger.info(f"   ‚Ä¢ Growth Rate: {GROWTH_RATE*100}%")
            logger.info(f"   ‚Ä¢ Symbol: {ATIVO}")
            logger.info(f"   ‚Ä¢ Account: {self.account_manager.account_name}")
            
            # USAR ACCOUNT MANAGER PARA EXECUTAR COMPRA
            start_time = time.time()
            contract_id = await self.account_manager.buy_accu(required_params)
            
            if contract_id:
                total_latency = (time.time() - start_time) * 1000
                logger.info(f"‚úÖ Compra ACCU executada via account_manager - Contract ID: {contract_id}")
                logger.info(f"‚ö° Lat√™ncia total: {total_latency:.2f}ms")
                
                # Atualizar timestamp da √∫ltima opera√ß√£o
                self._update_operation_timestamp()
                return contract_id
            else:
                logger.error(f"‚ùå Falha na compra ACCU via account_manager")
                return None
                
        except Exception as e:
            logger.error(f"‚ùå ERRO CR√çTICO na execu√ß√£o da compra: {e}")
            logger.error(f"üìã Tipo do erro: {type(e).__name__}")
            
            # FALLBACK: Tentar compra simplificada sem take_profit
            try:
                logger.info("üîÑ TENTANDO FALLBACK - Compra sem take_profit...")
                
                # ESTRUTURA FALLBACK VALIDADA (sem take_profit)
                fallback_proposal = {
                    "proposal": 1,
                    "contract_type": "ACCU",
                    "symbol": ATIVO,
                    "amount": float(stake_para_usar),
                    "basis": "stake",
                    "currency": "USD",
                    "growth_rate": GROWTH_RATE
                    # Sem limit_order para fallback
                }
                
                # Validar par√¢metros do fallback usando fun√ß√£o especializada
                if not self._validar_parametros_accu(fallback_proposal):
                    logger.error(f"‚ùå Valida√ß√£o dos par√¢metros ACCU do fallback falhou")
                    return None
                
                logger.info(f"üîÑ Executando fallback via account_manager...")
                
                # Executar fallback via account_manager
                contract_id = await self.account_manager.buy_accu(fallback_proposal)
                
                if contract_id:
                    logger.info(f"‚úÖ Compra fallback executada via account_manager - Contract ID: {contract_id}")
                    # Atualizar timestamp da √∫ltima opera√ß√£o
                    self._update_operation_timestamp()
                    return contract_id
                else:
                    logger.error(f"‚ùå Falha na compra fallback via account_manager")
                    return None
                        
            except Exception as fallback_error:
                logger.error(f"‚ùå FALLBACK tamb√©m falhou: {fallback_error}")
                
            return None
    
    async def monitorar_contrato(self, contract_id: str) -> float:
        """Monitora o contrato at√© o final e retorna o lucro/preju√≠zo"""
        logger.info(f"üëÅÔ∏è Monitorando contrato {contract_id}...")
        
        while True:
            try:
                response = await self.api_manager.proposal_open_contract(contract_id)
                
                if 'proposal_open_contract' in response:
                    contract = response['proposal_open_contract']
                    status = contract.get('status', 'open')
                    
                    if status in ['won', 'lost']:
                        profit = float(contract.get('profit', 0))
                        logger.info(f"üèÅ Contrato finalizado - Status: {status}, Lucro: ${profit:.2f}")
                        return profit
                    
                    # Log de progresso
                    current_spot = contract.get('current_spot', 0)
                    logger.info(f"üìà Contrato ativo - Spot atual: {current_spot}")
                
                await asyncio.sleep(2)  # Verificar a cada 2 segundos
                
            except Exception as e:
                logger.error(f"‚ùå Erro ao monitorar contrato: {e}")
                await asyncio.sleep(5)
    
    def aplicar_gestao_risco(self, lucro: float):
        """Gest√£o SEM Martingale - stake sempre fixo"""
        logger.info(f"üíº GEST√ÉO DE RISCO (STAKE FIXO) - Lucro: ${lucro:.2f}")
        
        # Calcular percentual para log
        profit_percentage = (lucro / self.stake) * 100 if self.stake > 0 else 0
        operation_result = "WIN" if lucro > 0 else "LOSS"
        
        # Enviar para Supabase
        asyncio.create_task(self.log_to_supabase(operation_result, profit_percentage, self.stake))
        
        # SEMPRE manter stake fixo (SEM Martingale)
        self.stake = STAKE_INICIAL  # Sempre fixo
        
        if lucro > 0:
            self.total_profit += lucro  # Acumular lucro total
            logger.info(f"üéâ WIN - Stake mantido: ${self.stake:.2f}")
            
            # Verificar Win Stop
            if self.total_profit >= self.win_stop:
                logger.info(f"üéØ WIN STOP ATINGIDO! Total: ${self.total_profit:.2f}")
                return "STOP_WIN"
        else:
            logger.info(f"üí∏ LOSS - Stake mantido: ${self.stake:.2f}")
            
            # Verificar Loss Limit (baseado em n√∫mero de perdas consecutivas)
            if abs(lucro) * 200 >= self.loss_limit:  # Exemplo: 200 perdas de $5 = $1000
                logger.info(f"üõë LOSS LIMIT ATINGIDO!")
                return "STOP_LOSS"
        
        logger.info(f"üìä Estado atual: Stake=${self.stake:.2f} (FIXO), Total Profit=${self.total_profit:.2f}")
    
    async def executar_ciclo_trading(self):
        """Executa um ciclo completo de trading"""
        self.ciclo += 1
        logger.info(f"\nüîÑ CICLO {self.ciclo} - {datetime.now().strftime('%H:%M:%S')}")
        
        # 1. Obter √∫ltimos 5 ticks
        ticks = await self.obter_ultimos_5_ticks()
        if len(ticks) < 4:
            logger.warning("‚ö†Ô∏è Ticks insuficientes para an√°lise")
            return
        
        # 2. Analisar padr√£o de entrada
        if not self.analisar_padrao_entrada(ticks):
            logger.info("‚è≥ Aguardando padr√£o de entrada...")
            return
        
        # 3. Executar compra
        contract_id = await self.executar_compra_accu()
        if not contract_id:
            logger.error("‚ùå Falha na execu√ß√£o da compra")
            return
        
        # 4. Monitorar contrato
        lucro = await self.monitorar_contrato(contract_id)
        
        # 5. Aplicar gest√£o de risco
        self.aplicar_gestao_risco(lucro)
    
    async def start(self):
        """Inicia o bot com tick stream subscription em tempo real"""
        logger.info("\n" + "="*70)
        logger.info(f"üöÄ INICIANDO {NOME_BOT} - MODO TEMPO REAL")
        logger.info("="*70)
        logger.info(f"üìÖ Iniciado em: {datetime.now().strftime('%d/%m/%Y %H:%M:%S')}")
        logger.info(f"üéØ Estrat√©gia: Padr√£o Red-Red-Red-Blue (3 subidas + 1 queda)")
        logger.info(f"üí∞ Stake inicial: ${STAKE_INICIAL}")
        logger.info(f"üìà Take Profit: {TAKE_PROFIT_PERCENTUAL*100}%")
        logger.info(f"üìä Ativo: {ATIVO}")
        logger.info(f"üîÑ Growth Rate: {GROWTH_RATE*100}%")
        logger.info(f"‚öñÔ∏è Gest√£o: Stake fixo (sem martingale)")
        logger.info(f"‚ö° NOVO: An√°lise em tempo real via tick stream")
        logger.info("="*70)
        
        # Conectar √† API
        if not await self.api_manager.connect():
            logger.error("‚ùå Falha na conex√£o inicial. Encerrando.")
            return
        
        # Configurar callback do bot na API
        self.api_manager.set_bot_instance(self)
        
        try:
            # Pr√©-validar par√¢metros
            if not self._pre_validate_params():
                logger.error("‚ùå Falha na pr√©-valida√ß√£o de par√¢metros")
                return
            
            # Iniciar subscription de ticks em tempo real
            logger.info(f"üì° Iniciando subscription de ticks para {ATIVO}...")
            await self.api_manager.subscribe_ticks(ATIVO)
            self.tick_subscription_active = True
            
            # Iniciar processamento de sinais da queue
            logger.info("üöÄ Iniciando processamento de sinais da queue...")
            signal_processor_task = asyncio.create_task(self._process_signals_from_queue())
            
            # Iniciar monitoramento em tempo real
            logger.info("üìä Iniciando monitoramento em tempo real...")
            monitoring_task = asyncio.create_task(self._real_time_monitoring())
            
            # Iniciar servidor HTTP para endpoint /status
            logger.info("üåê Iniciando servidor HTTP...")
            http_server_task = asyncio.create_task(self._start_http_server())
            
            # Iniciar Health Monitor em paralelo
            logger.info("üè• Iniciando Health Monitor...")
            health_monitor_task = asyncio.create_task(
                self.health_monitor.monitor_and_recover(
                    stats_provider=self._get_enhanced_stats,
                    check_interval=30.0
                )
            )
            
            logger.info("‚úÖ Bot em modo tempo real - aguardando ticks...")
            logger.info("üéØ Padr√£o ser√° analisado automaticamente a cada tick recebido")
            logger.info("‚ö° Sistema de sincroniza√ß√£o aprimorado ativo")
            logger.info("üåê Endpoint de status dispon√≠vel em http://localhost:8080/status")
            logger.info("üîß Sistemas Avan√ßados Ativos:")
            logger.info("   ‚Ä¢ Enhanced Tick Buffer: ‚úÖ Otimiza√ß√£o de dados")
            logger.info("   ‚Ä¢ WebSocket Recovery: ‚úÖ Auto-recupera√ß√£o")
            logger.info("   ‚Ä¢ Signal Queue: ‚úÖ Processamento paralelo")
            logger.info("   ‚Ä¢ Health Monitor: ‚úÖ Monitoramento cont√≠nuo")
            
            # Loop de monitoramento principal
            while True:
                try:
                    # Verificar se subscription ainda est√° ativa
                    if not self.api_manager.connected:
                        logger.warning("‚ö†Ô∏è Conex√£o perdida - tentando reconectar...")
                        await self._reconnect_and_resubscribe()
                    
                    # Verificar inatividade e reiniciar se necess√°rio
                    await self._check_inactivity_and_restart()
                    
                    # Aguardar antes da pr√≥xima verifica√ß√£o
                    await asyncio.sleep(15)  # Verifica√ß√£o de conectividade a cada 15s
                    
                except Exception as e:
                    logger.error(f"‚ùå ERRO NO MONITORAMENTO: {e}")
                    logger.error(f"üìã Tipo do erro: {type(e).__name__}")
                    logger.error("‚è∏Ô∏è Pausando por 15 segundos para recupera√ß√£o...")
                    
                    await asyncio.sleep(15)
                    await self._reconnect_and_resubscribe()
                    
        except Exception as e:
            logger.error(f"‚ùå ERRO CR√çTICO NO SISTEMA DE TEMPO REAL: {e}")
            logger.error("üîÑ Tentando reiniciar sistema...")
            await self._reconnect_and_resubscribe()
    
    async def _reconnect_and_resubscribe(self):
        """Reconecta e reinicia subscription de ticks com recupera√ß√£o autom√°tica"""
        try:
            logger.info("üîÑ Iniciando recupera√ß√£o autom√°tica...")
            
            # Resetar flags
            self.tick_subscription_active = False
            
            # Auto-reset do circuit breaker se necess√°rio
            circuit_state = self.robust_order_system.circuit_breaker_state
            if circuit_state != 'CLOSED':
                logger.info(f"üîß Auto-reset do circuit breaker (estado: {circuit_state})")
                self.robust_order_system.reset_circuit_breaker()
            
            # Limpar buffer de ticks para evitar dados obsoletos
            self.tick_buffer.clear()
            logger.debug("üßπ Buffer de ticks limpo")
            
            # Reconectar com retry
            max_retries = 3
            for attempt in range(max_retries):
                try:
                    logger.info(f"üîå Tentativa de reconex√£o {attempt + 1}/{max_retries}")
                    
                    if await self.api_manager.connect():
                        logger.info("‚úÖ Reconex√£o bem-sucedida")
                        break
                    else:
                        logger.warning(f"‚ö†Ô∏è Falha na tentativa {attempt + 1}")
                        if attempt < max_retries - 1:
                            await asyncio.sleep(5 * (attempt + 1))  # Delay progressivo
                except Exception as conn_error:
                    logger.error(f"‚ùå Erro na tentativa {attempt + 1}: {conn_error}")
                    if attempt < max_retries - 1:
                        await asyncio.sleep(5 * (attempt + 1))
            else:
                logger.error("‚ùå Falha em todas as tentativas de reconex√£o")
                return False
            
            # Reconfigurar callback
            self.api_manager.set_bot_instance(self)
            
            # Reiniciar subscription com valida√ß√£o
            try:
                await self.api_manager.subscribe_ticks(ATIVO)
                self.tick_subscription_active = True
                logger.info("üì° Subscription de ticks reestabelecida")
            except Exception as sub_error:
                logger.error(f"‚ùå Erro ao reestabelecer subscription: {sub_error}")
                return False
            
            # Validar conectividade
            await asyncio.sleep(2)  # Aguardar estabiliza√ß√£o
            if self.api_manager.connected and self.tick_subscription_active:
                logger.info("‚úÖ Recupera√ß√£o autom√°tica conclu√≠da com sucesso")
                return True
            else:
                logger.error("‚ùå Falha na valida√ß√£o p√≥s-recupera√ß√£o")
                return False
            
        except Exception as e:
            logger.error(f"‚ùå Erro cr√≠tico na recupera√ß√£o autom√°tica: {e}")
            await asyncio.sleep(10)
            return False

# ============================================================================
# THUNDERBOT MULTI-ACCOUNT MANAGER - AUTO-CONTIDO
# ============================================================================
class ThunderBotMultiAccountManager:
    """Gerenciador avan√ßado para m√∫ltiplas inst√¢ncias do ThunderBot com prote√ß√µes integradas"""
    
    def __init__(self, accounts_config):
        self.accounts_config = accounts_config
        self.bot_instances = {}
        self.active_bots = []
        
        # Componentes auxiliares integrados
        self.operation_queue = ThunderBotOperationQueue("MultiAccount")
        self.account_managers = {}  # Dict de ThunderBotAccountManager
        self.health_monitor = None  # Ser√° inicializado ap√≥s criar account_managers
        self.circuit_breaker = CircuitBreaker(failure_threshold=3, recovery_timeout=30)
        self.connection_managers = {}
        
        # Estado do sistema
        self.is_running = False
        self.start_time = None
        
        logger.info(f"‚ö° ThunderBotMultiAccountManager inicializado com {len(accounts_config)} contas")
        logger.info(f"üîß Componentes: ThunderBotOperationQueue, ThunderBotAccountManager, ThunderBotHealthMonitor, CircuitBreaker")
    
    async def initialize_bots(self):
        """Inicializa todas as inst√¢ncias do bot para as contas ativas com prote√ß√µes"""
        logger.info("üîÑ Iniciando inicializa√ß√£o dos bots ThunderBot...")
        
        for account in self.accounts_config:
            try:
                # Valida√ß√£o rigorosa de conta
                if not self._validate_account(account):
                    continue
                
                # Criar account manager para a conta
                account_manager = ThunderBotAccountManager(account['name'], account)
                self.account_managers[account['name']] = account_manager
                
                # Inicializar bot com circuit breaker
                bot = await self.circuit_breaker.call(self._initialize_single_bot, account, account_manager)
                
                if bot:
                    self.bot_instances[account['name']] = bot
                    self.active_bots.append(bot)
                    
                    logger.info(f"‚úÖ ThunderBot inicializado: {account['name']}")
                else:
                    logger.error(f"‚ùå Falha na inicializa√ß√£o: {account['name']}")
                
            except Exception as e:
                logger.error(f"‚ùå Erro cr√≠tico ao inicializar {account['name']}: {e}")
                # self.health_monitor.record_operation(success=False)  # Comentado at√© health_monitor ser inicializado
        
        # Inicializar health monitor ap√≥s criar account managers
        if self.account_managers:
            self.health_monitor = ThunderBotHealthMonitor(self.account_managers)
            logger.info("‚úÖ ThunderBotHealthMonitor inicializado")
        
        logger.info(f"üéØ ThunderBots ativos: {len(self.active_bots)}")
        return len(self.active_bots) > 0
    
    def _validate_account(self, account):
        """Valida√ß√£o rigorosa de configura√ß√£o de conta"""
        if not account.get('enabled', True):
            logger.info(f"‚è≠Ô∏è Conta desabilitada: {account['name']}")
            return False
        
        if not account.get('token') or len(account['token']) < 10:
            logger.warning(f"‚ö†Ô∏è Token inv√°lido para: {account['name']}")
            return False
        
        if account['token'].startswith('SEU_TOKEN_') or not account['token']:
            logger.warning(f"‚ö†Ô∏è Token placeholder para: {account['name']}")
            return False
        
        logger.info(f"‚úÖ Conta validada: {account['name']}")
        return True
    
    async def _initialize_single_bot(self, account, account_manager):
        """Inicializa um bot individual com tratamento de erro"""
        try:
            logger.info(f"ü§ñ Criando ThunderBot para: {account['name']}")
            bot = AccumulatorScalpingBot(account, account_manager)
            
            # Teste de conectividade
            if hasattr(bot, 'api_manager'):
                await bot.api_manager.connect()
            
            return bot
        except Exception as e:
            logger.error(f"‚ùå Erro na cria√ß√£o do bot {account['name']}: {e}")
            return None
    
    async def start_all_bots(self):
        """Inicia todos os bots com monitoramento avan√ßado"""
        if not self.active_bots:
            logger.error("‚ùå Nenhum ThunderBot ativo para iniciar")
            return False
        
        self.is_running = True
        self.start_time = time.time()
        
        logger.info(f"üöÄ Iniciando {len(self.active_bots)} ThunderBots simultaneamente...")
        
        # Criar tasks com monitoramento individual
        tasks = []
        for bot in self.active_bots:
            task = asyncio.create_task(self._run_bot_with_advanced_monitoring(bot))
            tasks.append(task)
        
        # Iniciar task de monitoramento de sa√∫de
        health_task = asyncio.create_task(self._health_monitoring_loop())
        tasks.append(health_task)
        
        try:
            await asyncio.gather(*tasks, return_exceptions=True)
        except Exception as e:
            logger.error(f"‚ùå Erro na execu√ß√£o dos ThunderBots: {e}")
            return False
        
        return True
    
    async def _run_bot_with_advanced_monitoring(self, bot):
        """Executa bot individual com monitoramento avan√ßado e auto-recupera√ß√£o"""
        bot_name = bot.account_name
        retry_count = 0
        max_retries = 3
        
        while self.is_running and retry_count < max_retries:
            try:
                logger.info(f"ü§ñ Iniciando ThunderBot: {bot_name} (tentativa {retry_count + 1})")
                
                # Executar bot com circuit breaker
                await self.circuit_breaker.call(bot.start)
                self.health_monitor.record_operation(success=True)
                
            except Exception as e:
                retry_count += 1
                self.health_monitor.record_operation(success=False)
                
                logger.error(f"‚ùå Erro no ThunderBot {bot_name}: {e}")
                
                if retry_count < max_retries:
                    wait_time = min(30 * retry_count, 300)  # Backoff exponencial limitado
                    logger.info(f"üîÑ Reiniciando {bot_name} em {wait_time}s...")
                    await asyncio.sleep(wait_time)
                else:
                    logger.error(f"üíÄ ThunderBot {bot_name} falhou definitivamente")
                    break
    
    async def _health_monitoring_loop(self):
        """Loop de monitoramento de sa√∫de do sistema"""
        while self.is_running:
            try:
                await asyncio.sleep(60)  # Check a cada minuto
                
                health_status = self.health_monitor.get_health_status()
                account_stats = self.account_manager.get_account_stats()
                
                logger.info(f"üíì Status: {health_status['status']} | "
                          f"Opera√ß√µes: {health_status['total_operations']} | "
                          f"Erro: {health_status['error_rate_percent']:.1f}% | "
                          f"Contas ativas: {account_stats['active_accounts']}")
                
                # Alertas autom√°ticos
                if not self.health_monitor.is_healthy():
                    logger.warning(f"‚ö†Ô∏è Sistema em estado degradado: {health_status['status']}")
                
            except Exception as e:
                logger.error(f"‚ùå Erro no monitoramento de sa√∫de: {e}")
    
    async def distribute_operation(self, operation_data):
        """Distribui opera√ß√£o usando account manager integrado"""
        try:
            account = self.account_manager.get_next_account()
            if account and account['name'] in self.bot_instances:
                bot = self.bot_instances[account['name']]
                await self.operation_queue.add_operation({
                    'bot': bot,
                    'data': operation_data,
                    'timestamp': time.time()
                })
                logger.info(f"üìä Opera√ß√£o distribu√≠da para: {account['name']}")
                return True
            else:
                logger.warning("‚ö†Ô∏è Nenhuma conta dispon√≠vel para opera√ß√£o")
                return False
        except Exception as e:
            logger.error(f"‚ùå Erro na distribui√ß√£o de opera√ß√£o: {e}")
            return False
    
    async def get_comprehensive_statistics(self):
        """Retorna estat√≠sticas abrangentes do sistema"""
        total_profit = 0.0
        total_operations = 0
        bot_stats = []
        
        for bot in self.active_bots:
            bot_profit = getattr(bot, 'total_profit', 0.0)
            bot_ops = getattr(bot, 'ciclo', 0)
            
            total_profit += bot_profit
            total_operations += bot_ops
            
            bot_stats.append({
                'name': bot.account_name,
                'profit': bot_profit,
                'operations': bot_ops,
                'status': 'active'
            })
        
        health_status = self.health_monitor.get_health_status()
        account_stats = self.account_manager.get_account_stats()
        
        return {
            'system': {
                'status': health_status['status'],
                'uptime': health_status['uptime_seconds'],
                'total_profit': total_profit,
                'total_operations': total_operations,
                'error_rate': health_status['error_rate_percent']
            },
            'accounts': account_stats,
            'bots': bot_stats,
            'queue': {
                'is_empty': self.operation_queue.is_empty(),
                'processing': self.operation_queue.processing
            }
        }
    
    async def shutdown(self):
        """Desligamento seguro do sistema"""
        logger.info("üõë Iniciando desligamento do ThunderBotMultiAccountManager...")
        
        self.is_running = False
        
        # Desconectar todos os connection managers
        for name, conn_manager in self.connection_managers.items():
            try:
                await conn_manager.disconnect()
                logger.info(f"‚úÖ Desconectado: {name}")
            except Exception as e:
                logger.error(f"‚ùå Erro ao desconectar {name}: {e}")
        
        logger.info("‚úÖ ThunderBotMultiAccountManager desligado com sucesso")

# Manter compatibilidade com c√≥digo existente
MultiAccountManager = ThunderBotMultiAccountManager

# ============================================================================
# FUN√á√ÉO PRINCIPAL - THUNDERBOT EXCLUSIVO
# ============================================================================
@with_error_handling(ErrorType.SYSTEM, ErrorSeverity.CRITICAL)
async def main():
    """
    Fun√ß√£o principal do ThunderBot
    USA EXCLUSIVAMENTE: Token 5iD3wgrYUz39kzS + App ID 105327
    """
    logger = logging.getLogger("ThunderBot.Main")
    logger.info("="*60)
    logger.info("INICIANDO THUNDERBOT - Multi-Account System")
    logger.info("="*60)
    
    # Exibir configura√ß√£o de seguran√ßa
    logger.info(f"Contas ativas: {len(ACTIVE_THUNDERBOT_ACCOUNTS)}")
    for acc in ACTIVE_THUNDERBOT_ACCOUNTS:
        logger.info(f"  - {acc['name']}: Token ...{acc['token'][-4:]} | App ID: {acc['app_id']}")
    
    # Valida√ß√£o de seguran√ßa
    if not any(acc['token'] == '5iD3wgrYUz39kzS' for acc in ACTIVE_THUNDERBOT_ACCOUNTS):
        raise Exception("ERRO: Token principal n√£o encontrado!")
    
    # Inicializar gerenciador
    manager = ThunderBotMultiAccountManager(ACTIVE_THUNDERBOT_ACCOUNTS)
    
    try:
        await manager.initialize_bots()
        
        logger.info("‚úÖ Sistema pronto para operar!")
        logger.info("-"*60)
        
        # ===== SUA L√ìGICA DE ESTRAT√âGIA AQUI =====
        # (manter toda a l√≥gica existente, apenas adaptar chamadas)
        
        # Exemplo de como executar opera√ß√£o:
        # if condicao_de_entrada_satisfeita():
        #     resultado = await manager.execute_accu_strategy({
        #         'stake': 10,
        #         'symbol': 'R_100',
        #         'growth_rate': 0.03,
        #         'currency': 'USD'
        #     })
        
        # Loop principal (adaptar conforme sua l√≥gica atual)
        while True:
            # Sua l√≥gica de estrat√©gia aqui
            await asyncio.sleep(1)
    
    except KeyboardInterrupt:
        logger.info("\n[CTRL+C] Encerrando ThunderBot...")
    except Exception as e:
        logger.error(f"ERRO CR√çTICO: {e}")
    finally:
        await manager.shutdown()
        logger.info("ThunderBot encerrado com sucesso!")

# Executar apenas se for o arquivo principal
if __name__ == "__main__":
    asyncio.run(main())